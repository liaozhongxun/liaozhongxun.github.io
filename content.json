[{"title":"微信公众号开发","date":"2017-08-15T12:21:31.000Z","path":"2017/08/15/微信公众号开发/","text":"","tags":[]},{"title":"webpack","date":"2017-08-15T06:20:41.000Z","path":"2017/08/15/webpack/","text":"webpack优点与 react vue的模块化开发框架搭配的比较好 通过拆包、Plugin、Loader等方式实先按需加载、定制资源包等特点并且适用于大型项目 核心概念Module Chunk 定位","tags":[]},{"title":"布局","date":"2017-08-12T03:58:38.000Z","path":"2017/08/12/布局/","text":"Flex 布局设置flex模块12345678display:flex;/* * 1、将所有直接子元素display 设置成 block * 2、将消除直接子元素margin重叠现象 * 3、float属性将失效 * */ 基本概念容器(flex container)和项目(flex item)容器:设置display:flex;的元素称为容器项目:容器的直接子元素称为项目 主轴(main axis)和侧轴(cross axis)主轴: 在容器中项目的排列方向(水平或垂直), 默认从左往右测轴: 与主轴垂直的线、默认从上往下 12个CSS属性1、父容器6个属性123456789101112131415161718/*设置主轴方向 reverse 表示反向*/flex-direction: row|row-reverse|column|column-reverse|initial|inherit;/*控制容器中项目换行*//*如果项目中宽度超过父容器宽度,默认不会换行,宽度之和会被压缩到容器大小 */flex-wrap：nowrap | wrap | wrap-reverse/*合并以上两个属性*/flex-flow：&lt;' flex-direction '&gt; || &lt;' flex-wrap '&gt;;/*设置项目在容器中主轴方向的位置*/justify-content：flex-start | flex-end | center | space-between | space-around/*设置项目在容器中侧轴方向的位置*/align-items：flex-start | flex-end | center | baseline | stretch/*多行项目在哪容器中的位置*/align-content：flex-start | flex-end | center | space-between | space-around | stretch 2、子容器的6个属性12345678910111213141516171819/*更改项目的排列属性*/order:numbuer; /*值越小，越靠主轴起始位置*//*放大属性*//*如果项目宽度或高度之和小于主容器时使用,给所有设置该属性的项目增加宽度填满容器*/flex-grow:number; /*每个增加的宽度 = 多余宽度 / 所有项目number之和 * 每个项目的number; 默认值为0*//*缩小属性*//*如果项目宽度或高度之和大于主容器时,项目自动缩小*/flex-shrink:number; /*每个项目缩小值为 = number/(number*差值 之和) * 当前项目宽度 * 总差值;默认为1*//*设置项目在容器主轴方向的,大小|百分百|默认|基于内容自动计算*/flex-basis：&lt;length&gt; | &lt;percentage&gt; | auto | content/*前三个属性之和*/flex:number; /*设置当前项目与其他项目不同的排序方式*/align-self：auto | flex-start | flex-end | center | baseline | stretch 绝对居中123display: flex;justify-content: center;align-items: center;","tags":[]},{"title":"潭州课程","date":"2017-08-10T10:52:19.000Z","path":"2017/08/10/潭州课程/","text":"ECMAScript 6扩展部分变量123456789/* * 1、let * 特性没有与解析(不会有先申明后执行的过程) * 不能重复申明 * 块级作用域( &#123;&#125;为一个代码块 ) * * 2、const * 申明一个常量,不能被修改 但是对象中的值是可以改变的 */ 扩展运算符12var str = \"liao\"; //代表ES6中所有有遍历接口的数组或类数组 var arr = [...str] // arr = [\"l\",\"i\",\"a\",\"o\"] 结构赋值1234567891011121314/* * 1、数组结构赋值 * let [a,b,[c]] = [1,2,[3,5]] * //a ==1 b ==2 c==3 * * let [a,b,c] = [1,2,[3,5]] * //a ==1 b ==2 c==[3,5] * * 2、对象的节后赋值 * let obj = &#123;arr:[],str:''&#125;; * let &#123;arr,str&#125; = obj; * //arr==[] srt=='',对象的结构赋值键名要对的上 * */ 字符串1234567891011121314/* * 1、字符串拼接 * `字符串夹$&#123;bian量&#125;` * $&#123;&#125; 中可以直接运算 * 可直接换行 * * 2、字符串查找 * str.includes(\"char\") 如果找到返回true * str.startsWith(\"char\") 如果知道字符在头部返回true * str.endsWith(\"char\") 如果知道字符在尾部返回true * 第二个参数从第几位开始找 * * str.repeat(n) 复制字符串n遍 */ 正则扩展数值扩展1234567891011121314/* * 1、去除小数点(取整) * Math.trunc(num) * * 2、区分正负 * Math.sing(5) 1 * Math.sing(0) 0 * Math.sing(-5) -1 * Math.sing(-0) -0 * * 3、平方和的平方根 * Math.hypot(2,3) * */ 数组扩展12345678910111213141516171819202122232425/* * 1、类数组转数组(如字符串) * Array.from(leiarr) * * 2、接收一组参数，转为数组 * Array.of(1,2,3,4) * * 3、找到数组中符合条件的一个值 * arr.find(function(value,key)&#123; * return value &gt;3 * &#125;) * * 4、找到数组中符合条件的一个值的索引 * arr.findIndex(function(value,key)&#123; * return value &gt;3 * &#125;) * 5、数组填充 * arr.fill('ele',startIndex,endIndex) 包前不包后 * * 6、数组推到 * var arr = [1,2,3,4,5] * var arr2 = [for(value of arr) value*2] //arr2 = 2 4 7 8 10 * var arr2 = [for(value of arr) 可以加判断 value*2] //arr2 = 2 4 7 8 10 * */ 循环扩展12345678/* * 1、for of 循环 */for(var value of obj)&#123;&#125; //只能遍历有遍历接口的对象 //Object.values(obj)for(var key of arr.keys())&#123;&#125; //遍历数组的keyfor(var value of arr.values())&#123;&#125; //遍历数组的value (默认)for(var [key,value] of arr.entries())&#123;&#125; //遍历数组的key end value 对象Proxy 代理对象123456789var pro = new Proxy(obj,&#123; //obj就是要代理的对象,参数二就是对代理对象的处理 set(obj,attr,value)&#123; //对代理对象的设置就会先触发set方法 obj[attr] = value; &#125;, get(obj,attr)&#123; //对代理对象的访问就会先触发get方法 return 出去的值,就是你访问obj对象的attr属性所得到的值 &#125; &#125;)console.log(pro.a) //得到return出来的值 对象定义12345678910/* * var obj = &#123; * fn()&#123;&#125;, * [\"a\" + 'b']:\"123\" * &#125; * * 简写 * ES5 : return &#123;x:x,y:y&#125; * ES6 : return &#123;x,y&#125; */ 对象新增方法123456789101112131415/* * 1、判断参数是否相等 * Object.is(0,-0) false * 0 === -0 true * Object.is(NAN,NAN) true * * 2、多个obj赋值到一个里去 * Object.assign(obj,obj1,objn); 从后往前依次覆盖; * * 3、获取对象的 prototype * Object.getPrototypeOf(new Array()); * * 4、改变对象的 prototype * Object.setPrototypeOf(new Dog(),Cat.prototype); //将猫类的prototype覆盖到狗上 */ 函数传参、默认值1234567891011function fn(a,b,...c)&#123; // ...c必须放在最后 console.log(c) //[3,4,5,6] console.log(...c) // 3 4 5 6&#125;fn(1,2,3,4,5,6);function fn(a,b = 2)&#123; // b = 2必须放在最后 console.log(a) console.log(b) // 2&#125;fn(1) 箭头函数123456789let fn = (a,b) =&gt; &#123; alert(\"a\");&#125;//如果只有执行一行代码let fn = () =&gt; alert(\"a\");//如果只有一个参数,可省略小括号let fn = a =&gt; alert(\"a\"); 与真正函数的区别1、箭头函数不能 new2、箭头函数不存在 arquments3、this指向永远指向定义时所在的对象 ???? 新增数据结构Set123456789/* * let set = new Set([1,1,1,\"1\",2]); // let = [1,\"1\",2] * 1、set所有的值都是唯一的 * 2、set.size 相当于 arr.length * 3、set.add(ele) 追加 * 4、set.delect(ele) 删除 * 5、set.has(6) //判断set中是否有6这个元素 返回一个bool值 * 6、set.clear() //清空set中多有成员 */ WeaksetMap123456789/* * var map = new Map([[]]) //参数解构 [[key,value],[key,value]] 不会出现从复的key,这里的key值可以是对象、一个函数 * 1、map.size //成员数量 * 2、map.set(\"key\",\"value\") //新增值 * 3、map.get(\"key\") //获取 * 4、map.has(\"key\") //判断key是否存在 * 5、map.delete(\"key\") //删除key * 6、map.clear() //清空所有*/ Promise1234567891011121314151617181920212223242526272829303132333435var pro = new Promise(function(resolve,reject)&#123; //经过很多操作之后 //resolve() 代表成功状态,reject() 代表失败 ,可以传参 resolve();&#125;)&lt;!-- 直接.them --&gt;&lt;!-- .them(function()&#123; return new Promise(....) //上一个执行完之后接着走这里&#125;) --&gt;pro.then(function()&#123; console.log(\"成功\") //当上面执行 resolve() 的时候走这里&#125;,function()&#123; console.log(\"失败\") //当上面执行 reject() 的时候走这里&#125;).catch(function(e)&#123; //报错时走这里&#125;)---var pro3 = Promist.all([pro1,pro2]);pro3.then(function()&#123; //pro1 和 pro2 都成功(调用resolve())之后 &#125;,function()&#123; //pro1 和 pro2 只要有一个失败(调用reject())就马上走这里&#125;)---var pro3 = Promist.race([pro1,pro2]);pro3.then() //race函数的参数中 只要有一个的状态(变成调用resolve()) 改变,就走成功 Generator123456789101112131415161718192021function* helloWorldGenerator() &#123; yield 'hello'; yield 'world'; return 'ending'; //return代表函数结束了 //每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield语句（或return语句）为止。换言之，Generator函数是分段执行的，yield语句是暂停执行的标记，而next方法可以恢复执行。&#125;var hw = helloWorldGenerator(); //确保同一个对象hw.next() // &#123; value: 'hello', done: false &#125;hw.next()// &#123; value: 'world', done: false &#125;// next 传的参数通过上一次yield 的返回结果得到hw.next() //遇到return时 done为true// &#123; value: 'ending', done: true &#125;hw.next()// &#123; value: undefined, done: true &#125; async12345678/* * 1、在函数前加 async关键字 * async function fn()&#123; await p1(); &#125; * 2、 函数内部遇到 await 关键字时停止运行 ,并返回后面 Promise对象成功或失败传入的参数 * * 3、await 后边必须跟 Promise对象,当对象执行成功状态函数是往下执行 * 4、fn的return 就是 fn().them((data) =&gt;&#123;&#125;) 的data */ Class12345678910111213141516171819202122232425// 1class Cat&#123; constructor(name)&#123; //这个类的构造函数 this.name = name; &#125; getName()&#123; return this.name; &#125; static getColor(color)&#123; //静态方法 直接Cat.getColor()调用 console.log(color) &#125;&#125;// 2 继承class Cat2 extends Cat&#123; constructor(name,color)&#123; super(name) //在 constructor 内,super指代父类的contructor, //在 其他方法内,super指定父类的同名方法 this.color = color; &#125; getfafn()&#123; //调用父级的方法 super.getName() &#125;&#125;//已经继承了 并且有自己的color属性 nodejsnodejs是什么123Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型(异步运行)，使其轻量又高效。 Node.js 的包管理器 npm，是全球最大的开源库生态系统。 nodejs 与 javascript 类型 nodejs javascript 全局 global window nodejs不包含浏览器的相关操作 nodejs 常用的全局对象12345678//当前文件路径console.log(__filename);//当前文件文件夹console.log(__dirname);//process对象 获取node工作目录(根目录)console.log(process.cwd()); 模块(一个文件就是一个模块)12345678//引入 require('./1.js'); //后缀可以省略 ./代表当前目录 require('http'); //安装好node就带有的模块 叫核心模块,直接写模块名 //node_modules下的模块也是直接写名字 //模块的加载顺序: 文件夹名 &gt; 文件名.js &gt; 文件名.json &gt; 文件名.node//模块直接互相使用: module.exports = a; //将对象a暴露出模块,给其他require的文件使用 node底层服务器1234567891011//引入http模块const http = require( 'http');http.createServer((request,response) =&gt; &#123; //request 请求对象 浏览器请求服务器发送的内容 //response 相应对象 服务器返回给浏览器的内容 response.writeHead(200,&#123; 'Content-Type':'text/html'&#125;); response.end('Hello word'); //结束相应&#125;).listen(8088);// 运行该模块 访问 localhost:8088 就能显示响应的内容了// 后面如果有修改代码，要重启服务器代码才会生效 node工程配置目录1、配置文件: package.json1234567&#123; 'name':'项目名称', 'version':'1.0.0', 'dependencies':&#123; //依赖包 'express':'latest' //版本号，latest代表最新版本 &#125;&#125; 2、router目录 存放路由文件3、views目录 存放模板文件4、module目录 存放自己写的模块 路由模板引擎ejs1、设置123456express = require('express'),app = express();//初始化express express是封装过的服务器//设置模板引擎目录app.set('views',__dirname + '/views');//设置使用的模板引擎是什么app.set('view engine','ejs'); 2、调用123456789//响应模板引擎router.get('/ejs',(req,res) =&gt; &#123; //因为设置了模板引擎目录，所以这边直接写文件名 //因为设置了模板引擎目录格式，所以这边能省略扩展名 //json传递数据 //如果值是字符串 ejs文件中接收 &lt;%= name %&gt; //如果值是html标签并需要解析 ejs文件中接收 &lt;%- name %&gt; res.render('index',&#123;\"name\":\"lzoxun\"&#125;); //value也可以是json&#125;) 3、ejs语法&lt;% %&gt; 形式写js代码&lt;%=或- %&gt; 接收传递的值1234567891011//引入其他模板&lt;% include header.ejs %&gt;//接收模板传递的数据&lt;%= name %&gt;&lt;%- name %&gt;//编写js代码&lt;% for(var i=0;i&lt;10;i++)&#123; %&gt; 循环中 &lt;% &#125; %&gt; 静态资源1、设置123//设置静态资源目录 js img css//app.use('/dir',express.static(__dirname + '/public')) //这个目录下的dir 就是静态资源引用时的根目录app.use(express.static(__dirname + '/public')) //这个目录就是静态资源引用时的根目录 mySql数据库本地换xampp","tags":[]},{"title":"其他运用","date":"2017-08-10T07:21:43.000Z","path":"2017/08/10/其他运用/","text":"谷歌插件油猴脚本管理器 Tampermonkey 浏览器插件脚本下载网 百度直接下载脚本百度直接下载脚本地址123安装插件 Tampermonkey安装脚本安装完成之后打开分享的链接,才会出现已运行的脚本 网页限制解除通杀大部分网站，可以解除禁止复制、剪切、选择文本、右键菜单的限制。 专用链自动转换浏览器右键选择打开链接法式,入如打开了迅雷就能选择迅雷下载 nvm for window下载地址1[github下载](https://github.com/coreybutler/nvm-windows/releases) nvm常用命令1234567891011121314151617nvm install &lt;version&gt; ## 安装指定版本，可模糊安装，如：安装v4.4.0，既可nvm install v4.4.0，又可nvm install 4.4nvm uninstall &lt;version&gt; ## 删除已安装的指定版本，语法与install类似nvm use &lt;version&gt; ## 切换使用指定的版本nodenvm ls ## 列出所有安装的版本nvm ls-remote ## 列出所以远程服务器的版本（官方node version list）nvm current ## 显示当前的版本nvm alias &lt;name&gt; &lt;version&gt; ## 给不同的版本号添加别名nvm unalias &lt;name&gt; ## 删除已定义的别名nvm reinstall-packages &lt;version&gt; ## 在当前版本node环境下，重新全局安装指定版本号的npm包 快速安装1$ NVM_NODEJS_ORG_MIRROR=http://dist.u.qiniudn.com nvm install 8.2.1 移动真机调试连接USB Google调试(1) 使用数据线连接安卓手机和电脑(USB驱动一定要全部成功安装)(2) 进入手机设置中的开发者选项 , 打开USB调试 ,手机上会跳出弹出框(给予计算机权限)(3) 确定之后 在Google中输入 chrome://inspect/就能查看到连接成功的设备,如果没有就没连接成功(4) 用手机打开本机开启的页面,能访问的页面,会自动线上在 chrome://inspect/ 下(5) 点击其下面的连接inspect 就能弹出真机调试框了(6) 但是有由于Google需要下载一下插件,所以第一次使用需要翻墙(不然就是白茫茫的一片)(7) 安装成功之后就有内容显示了 使用插件调试 weinre(1) 通过一下代码安装weinre 并启动服务 12npm install weinre -g --registry=https://registry.npm.taobao.orgweinre --httpPort 8989 (端口随意设置) (2) 浏览器中输入 http://localhost:8989 打开页面 (3) 这里会尝产生一个脚本文件,引入要调试的页面 (4) 下图中有两个链接,第一个是入口文件,进去后就能看的引入脚本文件,并且在浏览器打开的地址了 spy-debugger 插件集成 weiner原文连接 里面还有iPhone的方法,和一些其他的调试文章命令行进本指令windows1234567891011121314151617explorer dirpath //弹出对应的文件夹mkdir 文件夹名 //创建文件夹cd&gt;文件名 //创建文件rd 文件夹名 //删除文件夹del 文件名/文件夹名 //删除文件或文件夹下的所有文件ren 旧文件名 新文件名 //重命名文件或文件夹type 文件名 //打印文件内容notepad 文件名 记事本打开编辑器名 文件名 //指定编辑器打开指定文件 ftp 命令123456789101112131415161718// 1 ftp连接服务器open lzoxun.top //回车后按照提示输入 ftp的用户名和密码close lzoxun.top //断开连接lcd d:\\ftpfile //定位本地默认文件夹 ,不跟路径默认c盘(每次连接都要设置)!dir //查看定位的文件夹的目录bin //采用二进制传输。如果你要上传下载，这一步很重要，不先执行这个命令，上传下载会很慢。mget //下载文件到本地(lcd设置的文件夹)//曾put //上传文件到服务器(相对lcd的文件夹路径或绝对路径)mput D:/ftpfile/* //上传所有文件//删mdelete //删除文件help //帮助 参考连接","tags":[]},{"title":"大总结","date":"2017-08-09T23:01:33.000Z","path":"2017/08/10/大总结/","text":"CSS溢出隐藏12345678910111213.div&#123; /*多行溢出省略号显示 不支持火狐*/ overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 1; -webkit-box-orient: vertical; /*单行*/ overflow: hidden; text-overflow: ellipsis; white-space:nowrap;&#125; 清除浮动123456789101112131415161718192021222324252627/*子级别最后加一个 clear:both;*/.clearfix&#123;//给浮动元素的父级加 &amp;:before, &amp;:after &#123; display:block; clear:both; content:\"\"; visibility:hidden; height:0 &#125; &amp;:after &#123; clear: both; &#125;&#125;.clear&#123; zoom:1; &amp;:after&#123; display:block; clear:both; content:\"\"; visibility:hidden; height:0 &#125; &#125; 1px解决方案1234567891011121314151617181920212223242526.ui-border &#123; position: relative; //必须 list-style: none; width: 100px; height: 30px; margin: 50px; display: flex; justify-content: center; align-items: center;&#125;.ui-border:before &#123; content: \"\"; width: 200%; height: 200%; position: absolute; top: 0; left: 0; -webkit-transform: scale(.5); -webkit-transform-origin: 0 0; padding: 1px; -webkit-box-sizing: border-box; pointer-events: none; border: 1px solid #ccc; border-radius: 8px;&#125; margin 折叠场景:两个或多个毗邻的普通流中的块元素垂直方向上的 margin 会折叠1、两个或多个 说明其数量必须是大于一个，又说明，折叠是元素与元素间相互的行为，不存在 A 和 B 折叠，B 没有和 A 折叠的现象。2、毗邻(上下或父子) 是指没有被非空内容、padding、border 或 clear 等分隔开，说明其位置关系。3、垂直方向 是指具体的方位，只有垂直方向的 margin 才会折叠，也就是说，水平方向的 margin 不会发生折叠的现象。 处理方式1、浮动元素、inline-block 元素、绝对定位元素的 margin 不会和垂直方向上其他元素的 margin 折叠 (出overflow属性外 基本创建了块级格式化上下文 BFC 的元素，不和它的毗邻发生 margin 折叠)2、用特殊手段将它们分开(如 &amp;nbsp ;、边框等) BFC 块级格式化上下文形成:BFC是一个HTML盒子并且至少满足下列条件中的任何一个 float的值不为none position的值不为static或者relative display的值为 table-cell, table-caption, inline-block, flex, 或者 inline-flex中的其中一个 overflow的值不为visible 其他12345/*title与alt的区别*/alt:图片得不到正常显示时提示文字title:鼠标滑过时的提示文字&lt;meta name=\"renderer\" content=\"webkit\" /&gt; /*使360浏览器默认使用webkit模式*/ Javascript关键字1234567891011121314151617181920/* * 1、arguments //函数参数列表,是一个类数组有length属性 * arguments.callee() //函数内部使用，表示当前函数自身,降低耦合度(改变一处代码,不会影响其他代码) * * * * * * * * * * * * * * * * */ 常用属性12345/* * 1、获取元素的类 * element.classList * */ 关键语法123456789101112/* * 1、匿名函数自调用 * (function()&#123;&#125;) (); //前面小括号提高优先级，后面为调用 * * 2、预加载 * 浏览器熏染js代码是先执行定义变量或函数的过程，后执行使用过程,重名覆盖 * * * * * */ 闭包概念:两个互相嵌套的函数，内部函数如果被return出来，就形成了闭包 123456789101112131415161718192021/* * 1、由于是引用赋值所有外面能访问到里面的局部变量 * 2、同一个闭包赋值给多个变量，彼此都是独立的互不影响 * 3、for循环中外面使用变量i * 解决方法:如果函数在内部直接使用可通过匿名函数自执行或将i存起来 * 如果函数需要在外部随机执行就在匿名函数内生成闭包 * */ //闭包出来for循环中i的问题var arr = []; for(var i=0;i&lt;4;i++)&#123; arr[i] = (function(n)&#123; return function()&#123; console.log(n); &#125; &#125;)(i) &#125; console.log(arr[0]()) console.log(arr[1]()) console.log(arr[2]()) console.log(arr[3]()) call和apply作用:更改作用于指向123456/* * 1、call * 函数.call(函数内部this指向,实参，实参) * 2、apply * 函数.apply(函数内部this指向,[实参列表]) */ 构造函数123456789/* * 1、构造函数中return的影响 * 如果return的是引用类型，则new出来的东西就是return出的对象 * 否则后续代码不生效 * * 2、一个函数的构造器是 Function * var fn = new Function('xc1','xc2','方法体'); * */ 事件绑定123456789101112131415//js中addachEvent,addEventListener的使用方法//非IE浏览器的动态添加,注销事件的方法el.addEventListener('click', msg, false);//添加el.removeEventListener('click', msg, false);//注销//IE中动态添加事件的方法el.attachEvent('onclick',msg);//添加el.detachEvent('onclick',msg);//注销function addEvent(obj,sEv,fn)&#123; if(obj.addachEvent)&#123; obj.addachEvent('on'+sEv,fn); &#125;else&#123; obj.addEventListener(sEv,fn,false); &#125;&#125; jQuery 原型12345678910111213141516171819202122232425262728293031323334353637383940function jQuery(arg)&#123; this.event = []; switch(typeof arg)&#123; case 'function': addEvent(window,load,arg);break; case 'string': switch(arg.charAt(0))&#123; case '#': this.event = document.getElementById(arg.substring(1)); break; case '.':break; default:break; &#125;; break; case 'object': break; default: break; &#125;&#125;jQuery.prototype = &#123; click:function(fn)&#123; for(var i=0;i&lt;this.event.length;i++)&#123; addEvent(this.event[i],'click',fn) &#125;; &#125;&#125;function $(arg)&#123; return new jQuery(arg);&#125;function addEvent(obj,sEv,fn)&#123; if(obj.addachEvent)&#123; obj.addachEvent('on'+sEv,fn); &#125;else&#123; obj.addEventListener(sEv,fn,false); &#125;&#125; 内存1内存 =&gt; 常量池、栈(存放变量,变量存储`地址`)、堆(存放对象 object) 、或者还有代码空间存放方法体等 获取 link 和 style 标签写入的样式1234567891011var obj = document.styleSheets[0]; // [object StyleSheetList] 样式表的个数&lt;link&gt;var rule = null;// [object CSSRule]if (obj.cssRules)&#123; rule = obj.cssRules[0]; // 非IE [object CSSRuleList]&#125; else &#123; rule = obj.rules[0]; // IE [object CSSRuleList]&#125; alert(rule.style.width); //cssRules(或rules)只能获取到内联和链接样式的宽和高，不能获取到行内和计算后的样式。 知识点空间、域名、ftp12345678910111213141516171819202122 1、 购买好空间，到空间管理那去绑定你的域名(注意绑定两个有www的和没有www的，重定向) 2、到域名管理去域名解析(如果空间的解析别名是ip形式，则域名解析时选A。如果是网址形式，就选CNAME) 3、域名解析时把解析别名填到纪录值那就行了 4、一般空间都支持ftp功能(这是购买空间时要注意事项之一)，在你的空间管理下面会提供ftp链接的用户名密码，以及ftp上传地址FTP链接: 1、链接 建一个站点，一般以域名为站点名 下面的地址就是上传地址，端口号一般默认，用户名密码是空间下提供的那个 链接好就行了 2、上传文件 上传压缩文件，要的空间的文件管理里面解压，ftp不能直接解压的(有些空间只能解压特点格式的压缩文件) github项目123456789//vue 项目sls-adminvue-element-admin//简历模板1、https://github.com/jirengu-inc/animating-resumehttp://codepen.io/jakealbaugh/full/JoVrdw/ //原文2、vue-resume 其他谷歌浏览器处理跨域1--disable-web-security --user-data-dir","tags":[]},{"title":"utils--工具方法库","date":"2017-08-02T11:01:28.000Z","path":"2017/08/02/utils-工具方法库/","text":"通过class查找元素1234567891011121314function getClass(onlyHtml,whatClass)&#123; var ele = onlyHtml.getElementsByTagName(\"*\"); var result = []; var classList = []; for(var i = 0; i&lt;ele.length; i++)&#123; classList = ele[i].className.split(\" \"); for(var j = 0;j&lt;classList.length;j++)&#123; if(classList[j] == whatClass)&#123; result.push(ele[i]); &#125; &#125; &#125; return result;&#125;","tags":[]},{"title":"vue.js","date":"2017-01-15T04:56:14.000Z","path":"2017/01/15/vue-js/","text":"vue基础 vue1.0vue1.0对象的属性1234567891011121314151617181920212223242526272829var vm = new Vue(&#123; el:'#box', //容器 data:&#123; //数据 msg:\"data\", a:1 &#125;, methods:&#123; //普通方法 &#125;, computed:&#123; //计算属性(属性b随着其return中相关的属性改变而改变) b:function()&#123; //b是一个属性，使用方法和data里的属性一样，return的就是它的值 return a*3 &#125;, b2:&#123; //b是默认走get的写法，b2是完整写法 get:function()&#123; return a*3 &#125;, set:function(val)&#123; //val是对b2进行设置时赋的值 //对data的个个属性进行设置，之后还会执行get通过本身与属性的关系改变自己的值 &#125; &#125; &#125;, transitions:&#123; //定义所有动画名称 bounce:&#123; //与上面自定义动画名称对应 enterClass:'zoomInLeft', //进入时执行的动画 leaveClass:'zoomOutRight' //离开时执行的动画 &#125; &#125;&#125;) vue1.0的生命周期1234567891011121314151617181920212223242526272829var vm=new Vue(&#123; // 钩子函数 init:function()&#123; alert(\"实例刚被创建,还没属性什么的\") &#125;, created:function()&#123; alert('实例已经创建,已经有属性了'); &#125;, beforeCompile:function()&#123; alert('编译之前'); &#125;, compiled:function()&#123; alert('编译之后'); &#125;, ready:function()&#123; alert('插入到文档中'); &#125;, beforeDestroy:function()&#123; alert('销毁之前'); &#125;, destroyed:function()&#123; alert('销毁之后'); &#125;&#125;);/*点击页面销毁vue对象*/document.onclick=function()&#123; vm.$destroy();&#125;; vue1.0实例的方法1234567891011121314151617var vm = new Vue(&#123; el:'#box', //容器 data:&#123; //数据 msg:\"data\", a:1 &#125;, &#125;)vm.$el //DOM元素#boxvm.$data //就是实例的数据vm.$mount(\"#box\") //手动将vm实例对象挂载到#box上vm.$options //实例对象的配置参数vm.$detroy //销毁对象vm.$log() //查看现在的数据状态vm.$watch(\"data attr\",function()&#123; //监听data attr属性的变化 console.log(\"当data attr发生变化是就会执行这里\");&#125;,&#123;deep:true&#125;) //第三个参数是深度监听 过滤器1234567891011v-for=\"val in arr | filterBy a\" //值循环数组中含有a的v-for=\"val in arr | limitBy a\" //只要含有a的v-for=\"val in arr | limitBy 2\" //只要前两位v-for=\"val in arr | limitBy 2 1\" //只要两位，从第一位开始算v-for=\"val in arr | orderBy 1\" //正序排列v-for=\"val in arr | orderBy -1\" //倒叙排列//自定义过滤器 Vue.filter(\"过滤器名\",function(val,参数...)&#123; //val 是竖杆前变量的值 return 。。。。 //返回的就是处理后的值&#125;) 指令系统指令1234567891011121314151617181920212223242526272829303132```#### 自定义指令```javascript//加了 v-red 属性的原始字体就会变红Vue.directive(\"red\",function()&#123; this.el.style.color=\"red\"; //this.el 原生的加了指令的原始&#125;)//加了 v-color=\"'red'\" 颜色变红Vue.directive(\"color\", function(attr) &#123; this.el.style.color = attr;&#125;)//通过指令直接操作DOM元素Vue.directive('drag', function() &#123; var oDiv = this.el; // oDiv.onmousedown = function(ev) &#123; var disX = ev.clientX - oDiv.offsetLeft; var disY = ev.clientY - oDiv.offsetTop; document.onmousemove = function(ev) &#123; var l = ev.clientX - disX; var t = ev.clientY - disY; oDiv.style.left = l + 'px'; oDiv.style.top = t + 'px'; &#125;; document.onmouseup = function() &#123; document.onmousemove = null; document.onmouseup = null; &#125;; &#125;;&#125;); 过渡动画12//在行间加入 transition=\"定义的动画名称\"//css 样式中写出2.0那样的动画就行 animate.js 库 1、给要添加动画的东西加速 class=”animated”2、在行间加入 transition=”bounce” (自定义定义的动画名称)3、Vue配置加入transitions12345678var vm=new Vue(&#123; transitions:&#123; //定义所有动画名称 bounce:&#123; //与上面自定义动画名称对应 enterClass:'zoomInLeft', //进入时执行的动画 leaveClass:'zoomOutRight' //离开时执行的动画 &#125; &#125;&#125;); 组件1、定义组件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//方法一var Co = Vue.extend(&#123; data:function()&#123; //组件里面的数据必须是一个函数，并且必须返回一个json对象 retrun &#123; msg:\"标题\" &#125; &#125;, template:\"&lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;\"&#125;)Vue.component(\"组件名\",Co); //这样注册组件是全局组件//方法二var vm=new Vue(&#123; el:\"#box\", data:&#123; msg:\"标题\" &#125;, components:&#123; //这样注册组件是局部组件 '组件名'：Co, '组件名'：&#123; //直接定义 data()&#123; retrun &#123; msg:\"标题\" &#125; &#125;, template:\"&lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;\" &#125; &#125;&#125;);//方法三 动态组件//html 中&lt;component :is=\"com\"&gt;&lt;component&gt;//js 中var vm=new Vue(&#123; el:\"#box\", data:&#123; com:\"组件名\" &#125;, components:&#123; '组件名'：&#123; retrun &#123; msg:\"标题\" &#125; &#125;, template:\"&lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;\" &#125; &#125;&#125;);//随时切换com的value切换组件 2、组件信息传递父传子1234567891011121314151617181920212223242526272829//html&lt;template id=\"aaa\"&gt; &lt;h1&gt;11111&lt;/h1&gt; &lt;bbb :data=\"msg\" :data2=\"msg2\"&gt;&lt;/bbb&gt; //1传入&lt;/template&gt;//jsvar vm = new Vue(&#123; components: &#123; 'aaa': &#123; data() &#123; return &#123; msg: '我是父组件的数据', msg2: '我是父组件的数据2' &#125; &#125;, template: '#aaa', components: &#123; 'bbb': &#123; props: ['data','data2'], //2接收 // props: &#123; // 'data':'类型', // 'data2':'类型' // &#125;, template: '&lt;h3&gt;&#123;&#123;data&#125;&#125;&lt;/h3&gt;' //3显示我是父组件的数据 &#125; &#125; &#125; &#125;&#125;); vue2.0 变化小变化1、不支持片段代码 2、组件123var json = &#123;&#125;Vue.component(\"组件名\",json);//直接一个json不需要 Vue.extend(&#123;&#125;);//在实例中注册也可以 3、循环 –去掉了隐式一些变量 $index $key –之前: v-for=”(index,val) in array” –现在: v-for=”(val,index) in array” 如果循环的是json 参数二可以是key –循环时加上 :key=”index” //为了提升性能可以不加 4、自定义键盘指令 之前：Vue.directive(‘on’).keyCodes.ctrl=17; 现在: Vue.config.keyCodes.ctrl=17 5、过滤器 删除了所有内置过滤器，只能自定义过滤器 只是传参数方式改变了123Vue.filter('过滤器名',function(obj,参数1,参数n)&#123; //&#123;&#123; data | 过滤器 ('参数1','参数n')&#125;&#125; obj就是data return; 还是显示return出来处理后的值&#125;) 大变化vue2.0的生命周期12345678910111213141516171819202122232425262728var vm=new Vue(&#123; // 钩子函数 beforeCreate()&#123; console.log('组件实例刚刚被创建,还没属性'); &#125;, created()&#123; console.log('实例已经创建完成,有属性了'); &#125;, beforeMount()&#123; console.log('模板编译之前'); &#125;, mounted()&#123; console.log('模板编译完成'); &#125;, beforeDestroy()&#123; console.log('组件销毁之前'); &#125;, destroyed()&#123; console.log('组件销毁之后'); &#125;, //更新是新增的 beforeUpdate()&#123; console.log('组件更新之前'); &#125;, updated()&#123; console.log('组件更新完毕'); &#125;&#125;); 组件通信1、自己不能直接改父级传入的数据,但是能改传入的对象的属性2、单一事件管理组件通信(类似vuex) – 首先要在全声明一个所有组件都能访问到的vue对象 var Event = new Vue(); –这个Event 含有$emit() 和 $on() 事件分别发送数据和接收数据 –Event.$emit(“自定义事件名称”,data); 发送数据 –Event.$on(“自定义事件名称”,function(data){}.bind(this)) // 接收数据 并且绑定作用域 – 一个组件中发送一个数据 所有组件都能通过 Event.$on() 方式得到数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;智能社&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\"&gt; &lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\"&gt; &lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\"&gt; &lt;style&gt; &lt;/style&gt; &lt;script src=\"vue.js\"&gt;&lt;/script&gt; &lt;script&gt; //准备一个空的实例对象 var Event=new Vue(); var A=&#123; template:` &lt;div&gt; &lt;span&gt;我是A组件&lt;/span&gt; -&gt; &#123;&#123;a&#125;&#125; &lt;input type=\"button\" value=\"把A数据给C\" @click=\"send\"&gt; &lt;/div&gt; `, methods:&#123; send()&#123; Event.$emit('a-msg',this.a); &#125; &#125;, data()&#123; return &#123; a:'我是a数据' &#125; &#125; &#125;; var B=&#123; template:` &lt;div&gt; &lt;span&gt;我是B组件&lt;/span&gt; -&gt; &#123;&#123;a&#125;&#125; &lt;input type=\"button\" value=\"把B数据给C\" @click=\"send\"&gt; &lt;/div&gt; `, methods:&#123; send()&#123; Event.$emit('b-msg',this.a); &#125; &#125;, data()&#123; return &#123; a:'我是b数据' &#125; &#125; &#125;; var C=&#123; template:` &lt;div&gt; &lt;h3&gt;我是C组件&lt;/h3&gt; &lt;span&gt;接收过来的A的数据为: &#123;&#123;a&#125;&#125;&lt;/span&gt; &lt;br&gt; &lt;span&gt;接收过来的B的数据为: &#123;&#123;b&#125;&#125;&lt;/span&gt; &lt;/div&gt; `, data()&#123; return &#123; a:'', b:'' &#125; &#125;, mounted()&#123; //var _this=this; //接收A组件的数据 Event.$on('a-msg',function(a)&#123; this.a=a; &#125;.bind(this)); //接收B组件的数据 Event.$on('b-msg',function(a)&#123; this.b=a; &#125;.bind(this)); &#125; &#125;; window.onload=function()&#123; new Vue(&#123; el:'#box', components:&#123; 'com-a':A, 'com-b':B, 'com-c':C &#125; &#125;); &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"box\"&gt; &lt;com-a&gt;&lt;/com-a&gt; &lt;com-b&gt;&lt;/com-b&gt; &lt;com-c&gt;&lt;/com-c&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 过渡动画(1) 到2.0以后 transition 组件1234567891011121314151617181920//写法与内置事件&lt;transition name=\"fade\" @before-enter = \"fn\" //在四个状态的enter执行之前执行 @enter = \"fn\" //动画enter进入时执行 //回调中会有一个元素是当前使用动画的元素 @after-enter = \"fn\" //动画进入之后执行 @before-leave =\"fn\" @leave =\"fn\" @after-leave =\"fn\" //离开&gt; //运动东西(元素，属性、路由....)&lt;/transition&gt;//class定义:.fade-enter&#123;&#125; //初始状态.fade-enter-active&#123;&#125; //变化成什么样 -&gt; 当元素出来(显示).fade-leave&#123;&#125; //开始结束时初始状态.fade-leave-active&#123;&#125; //变成成什么样 -&gt; 当元素离开(消失)//一般只给 .fade-leave-active,.fade-enter-active 添加过渡 (2) vue2.0 与 animate.css 结合使用 –引入animate.css –给运动元素添加class=”animated” 添加到进入离开动画名前面 –给transition组件添加属性: enter-actioe-class=”进入动画名”,leave-active-class=”离开动画名” – 没有了实例属性中的那种写法了 (3) 配合animate多元素运动123456&lt;transition-group enter-active-class=\"zoomInLeft\" leave-active-class=\"zoomOutRight\"&gt; &lt;p v-show=\"show\" class=\"animated\" :key=\"1\"&gt;&lt;/p&gt; &lt;p v-show=\"show\" class=\"animated\" :key=\"2\"&gt;&lt;/p&gt;&lt;/transition-group&gt;//必须加唯一标志位 vue的插件vue-devtools vue调试插件 理顺组件的关系GitHub直接搜 vue-devtools vue-resource12345678910111213141516171819202122232425262728293031this.$http(.......) //默认使用get方式//get 无传值this.$http.get('a.txt').then(function(res)&#123; alert(res); //成功回调&#125;,function(res)&#123; alert(res); //失败回调&#125;);//get 传值this.$http.get('get.php',&#123; a:1, b:2 &#125;).then(function(res)&#123; alert(res.data);&#125;,function(res)&#123; alert(res.status);&#125;);//postthis.$http.post('post.php',&#123;a:1,b:20&#125;,&#123; emulateJSON:true //post要传一个头信息，这边是加这个标志&#125;).then(function(res)&#123; alert(res.data);&#125;,function(res)&#123; alert(res.status);&#125;);//jsonp 获取本域之外的数据(只要有接口的路径部分 + ？后面的回调和关键字的键值对就能正常访问了)this.$http.jsonp('https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su',&#123; wd:'a' //搜索关键字为a,wd是百度上关键字对应的键&#125;,&#123; jsonp:'cb' //设置回调函数名称，取你使用的接口上的回调函数名，默认callback不要设置&#125;).then(function(res)&#123; alert(res.data.s);&#125;,function(res)&#123; alert(res.status);&#125;); Vuex1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889// 1、在main.js文件中引入单独文件，并根路由一样存入vue实例中import store from './store'new Vue(&#123; store, el: '#app', render: h =&gt; h(App)&#125;)// 2、store.jsimport Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex);var state = &#123;//数据 count: 10 &#125;;const mutations = &#123; addNumber(state) &#123; //处理状态(数据)变化 state.count++; &#125;, lessNumber(state) &#123; state.count--; &#125;&#125;;const actions = &#123; //给mapActions组件提供的方法 increment: (&#123; //处理你要干什么，异步请求，判断，流程控制 commit &#125;) =&gt; &#123; commit('addNumber') //当组件中触发该方法时，指向mutations中的addNumber &#125;, decrement: (&#123; commit &#125;) =&gt; &#123; commit('lessNumber'); &#125;, clickOdd: (&#123; //state就是当前参考的stsate commit, state &#125;) =&gt; &#123; if (state.count % 2 == 0) &#123;//过滤 通过某个条件时才指向mutations中的addNumber commit('addNumber') &#125; &#125;, clickAsync: (&#123; commit &#125;) =&gt; &#123; new Promise((resolve) =&gt; &#123; setTimeout(function() &#123; commit('addNumber'); resolve(); &#125;, 1000); &#125;); &#125;&#125;;const getters = &#123; //给组件中 mapGetters 提供的数据 count(state) &#123; return state.count; &#125;, getOdd(state) &#123; return state.count % 2 == 0 ? '偶数' : '奇数'; &#125;&#125;;//需要导出Store对象export default new Vuex.Store(&#123; //把定义好的对象挂载到Vuex.Store中,大型项目最后分别设置一个文件 state, mutations, actions, getters&#125;);// 3、组件中使用import &#123;mapGetters, mapActions&#125; from 'vuex'export default&#123; computed:mapGetters([ //获取数据 跟data的数据一样使用 &#123;&#123;count&#125;&#125; 'count', 'getOdd' ]), methods:mapActions([ //获取方法 'increment', 'decrement', 'clickOdd', 'clickAsync' ])&#125; elementUi and MintUl饿了么提供的基于vue的开源ui框架(前者真的pc,后者针对移动端) 配置 安装 element-ui npm i element-ui -D npm install element-ui –save-dev // i -&gt; install // D -&gt; –save-dev // S -&gt; –save 引入 main.js 入口文件 import ElementUI from ‘element-ui’ import ‘element-ui/lib/theme-default/index.css’ //注意引入loder style!css 使用组件 Vue.use(ElementUI) 一般要配置文件loder 因为ui组件的图标格式很多要自己配置 使用","tags":[{"name":"前端MVVM框架","slug":"前端MVVM框架","permalink":"https://liaozhongxun.github.io/tags/前端MVVM框架/"}]},{"title":"mySQL","date":"2017-01-09T11:53:36.000Z","path":"2017/01/09/mySQL/","text":"mySQL 简介1、mysql分客户的和服务端2、安装mysql，默认root 过程中可设置密码 直接下载 v5.7.3 密码：6ctv3、安装数据库管理工具Navicat for MySQL 直接下载 密码：k9xt4、管理工具链接mySql账户 (随机链接名,主机地址,端口号,数据库的用户名与密码)5、单位: 库 =&gt; 表 =&gt; 行:每条数据、列:字段或域6、项目中通过安装mysql依赖包链接数据库 数据库的表1、字段的属性:字段名、类型、长度、是否小数点、是否为空、是否为主键等;2、主键的有点:一条数据的唯一标示、性能高、优先级高 mySQL 简单使用123456789/bin ==&gt; mysql.exe -uroot(u+账户名) -p 登入数据库//show databases; 展示数据库//create database 库名; 新建数据库//exit; 退出//修改密码 首先登录MySQL。 mysql&gt; use mysql; mysql&gt; update user set password=password(&apos;新密码&apos;) where user=&apos;root&apos; and host=&apos;localhost&apos;; mysql&gt; flush privileges; SQL 基础语法创建表1234567CREATE TABLE `node`.`user`( `id` INT(11) NOT NULL AUTO_INCREMENT, `username` varchar(64) NOT NULL , `pass` varchar(64) NOT NULL , PRIMARY KEY (`id`) //主键为id )ENGINE = InnoDB CHARSET=utf8; 设置编码 四大语句 —- 曾删改查曾 INSERT123INSERT INTO 表 (字段列表) VALUES (值列表)INSERT INTO usersheet (ID , username , password) VALUES (0,'lia','123456');#ID设置了自增用0占位 删 DELETE1DELETE FROM 表 WHERE 条件 改 UPDATE12UPDATE 表 SET 字段=VALUE,字段=VALUE WHERE 筛选条件#不加筛选条件所有这个字段都会更改 查 SELECT12SELECT 什么(通配符) FROM 表SELECT * FROM usersheet; 子句(顺序 WHERE =&gt; GROUP =&gt; ORDER =&gt; LIMIT)WHERE 筛选1WHERE 各种条件: &gt; &lt; AND OR ... ORDER 排序1234567ORDER BY 字段 ASC/DESCASC =&gt; 从小到大DESC =&gt; 从大到小#多多条件排序ORDER BY 字段 ASC,字段 DESC #如果前一种字段相同就按后一种排序 GROUP 聚类(合并相同数据)1234GROUP BY 字段 #以指定字段作为依据来分组 去重SELECT 字段,COUNT(字段) FROM 表 GROUP BY 字段 #得到每个不同字段出现几次统计的函数都可以用于 GROUP 的记录 LIMIT 限制12LIMIT 10; #只要前十条LIMIT 2,3; #从第二条开始，取三条 SQL语句标准写法 关键字大写、(库、表、字段)需要用``引起来 不遵循也可以 连接mysql123456789101112131415161718192021222324252627//js文件 模块const mysql = require(&quot;mysql&quot;);//1 连接//var db = mysql.createPool(&#123;用法一&#125;) //连接池 保持连接性能好var db = mysql.createConnection(&#123; host: &apos;localhost&apos;, //主机名 user: &apos;root&apos;, //数据库用户名 password: &apos;123456&apos;, //用户对应得密码 database: &apos;lzoxun&apos; //要用的数据库名 //prot:&apos;3306&apos; 端口号 默认3306 &#125;)//2 查询 db.query(干什么,回调) `SELECT * FROM usersheet` `$&#123;bianliang&#125;` db.query(&quot;SELECT * FROM `usersheet`;&quot;,function(err,data)&#123; if(err)&#123; console.log(&quot;出错了&quot;, err) &#125;else&#123; console.log(&quot;成功了&quot;, data) &#125; &#125;)//注:通过SQL =&gt; Structured Query Language 结构化查询语句 进行交互// SQL =&gt; 所有数据库操作的基础 // 所欲数据库都是通过SQL与编程语言通信的// SQL == DBA","tags":[]},{"title":"Atom","date":"2017-01-07T15:06:19.000Z","path":"2017/01/07/Atom/","text":"下载地址123456//插件//script ctrl+shift+b直接运行node代码//emmet-atom ctrl+alt+enter下方调出文本框框 直接输入//atom-beautify ctrl+alt+b 格式化代码 atom-beautify\\examples\\simple-jsbeautifyrc\\.jsbeautifyrc 设置格式化格式//minimap 右侧代码预览插件","tags":[{"name":"编辑器","slug":"编辑器","permalink":"https://liaozhongxun.github.io/tags/编辑器/"}]},{"title":"mongoDB","date":"2016-12-30T13:57:26.000Z","path":"2016/12/30/mongoDB/","text":"(1) 基本使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546//安装好之后,从bin目录中找到mongod.exe 和 mongo.exe//mongod 启动后台数据库，mongo 启动前台连接数据库(要在C盘创建一个 data/db目录)//启动mongoshow dbs //查看所有数据库 //新创建的数据库不在数据列表中，要插入一下数据才能显示db //显示当前数据库 //mongodb 分 数据库(database) =&gt; 集合() =&gt;文档对象//mysql 分 数据库 =&gt; 表 =&gt; 记录 use DATABASE_NAME //打开或创建数据库db.createCollection(\"集合名\") //手动在当前数据库下创建一个集合show collection //显示当前数据库下得集合db.集合名.insert(&#123;\"_id\":\"1\",\"name\":\"liaozhongxun\",\"age\":\"20\"&#125;) //往当前数据库的这个集合中插入一个文档对象(如果没有这个集合就默认创建一个)db.dropDatabase() //删除当前数据库db.集合名.drop() //删除当前数据库下得某个集合//=======================文档操作//通过insert给集合插入文档//db.集合名.save 也能新增文档//给集合添加文档时 _id(主键)重复 insert方式会报错,save方式会更新db.集合名.find() //显示当前表的所有记录(没有设置id的对象会自动添加一个)db.集合名.find().prettye //格式化查找到的记录 find中都能带条件db.集合名.find().count() //记录个数db.集合名.find().limit(3) //只要3条db.集合名.find().skip(3) //跳过第3条db.集合名.findOne() //显示符合要求的第一个对象db.集合名.updata(&#123;\"条件字段名\",\"条件字段值\"&#125;,&#123;$set:&#123;\"要修改的字段名\":\"修改后的字段值\"&#125;&#125;) //收到更新指定字段db.集合名.remove(&#123;\"条件字段名\",\"条件字段值\"&#125;) //删除指定文档db.集合名.remove() //删除所有文档//======================条件//&#123;\"age\":&#123;$gt:5&#125;&#125; 得到age &gt; 5 的所有记录//&#123;\"age\":&#123;$gt:5&#125;&#125;.sort(\"age\":1) 得到的记录中 按age升序//&#123;\"age\":&#123;$gt:5&#125;&#125;.sort(\"age\":-1) 得到的记录中 按age降序//=======================与nodejs连接","tags":[]},{"title":"Express","date":"2016-12-26T12:36:35.000Z","path":"2016/12/26/Express/","text":"(1)安装123456789101112$ npm install -g express-generator@4 //创建express工程$ express /tmp/foo &amp;&amp; cd /tmp/foo //创建不同的express工程,ejs模式比较简单$ express ejs expreEjs &amp;&amp; cd /expreEjs$ npm install$ npm start//访问 http://localhost:3000/","tags":[]},{"title":"nodejs","date":"2016-12-24T02:37:27.000Z","path":"2016/12/24/nodejs/","text":"NODEnode的基本概念1 (1) nodejs 是一个让JavaScript运行在服务端的平台 node内置全局变量 process 123456789101112131415161718//process//arr[0] 是node，arr[1]是脚本文件名，arr[3]开始每个元素是一个运行参数。console.log(precess.argv); //process.argv返回命令行参数数组process.stdout.write(\"\"); //标准输出流 console.log的底层也是这个process.stdin.resume(); //标准输入流process.stdin.on('data',function(data)&#123;//获取输入的数据 process.stdout.write(data) console.log(data) //得到的buffer值&#125;)//或process.stdin.on('readable', function() &#123; var chunk = process.stdin.read(); if (chunk !== null) &#123; process.stdout.write('data: ' + chunk); &#125;&#125;); Buffer 用于操作二进制数据流 123456789101112131415161718192021222324252627//创建Buffer对象 并且为这个对象分配一个大小//new Buffer(size||[]) 第二个参数能指定编码 //当为一个buffer对象分配了一个空间大小之后其长度是不能改变的var bf = new Buffer('liaozhongxun') console.log(bf);console.log(bf.length) // bf的字节长度console.log(String.fromCharCode( bf[0] )); //将bf二进制转化为字符var bf1 = new Buffer(9)bf1.write(\"liaozhong\",2,5) //只会写入五个字符,偏移,写入的长度,字符串的编码(默认utf-8)console.log(bf1) //只有bf1的第三个位置有一个值console.log( bf1.toString() ) //将bf对象转化为字符串console.log( bf1.toString(\"utf-8\",1,3) ) //从第一位开始 返回长度3 不包括第3个var bf2 = bf1.slice(2,3) //从位置2开始 到位置3 不包括3console.log(bf2) //bf2与bf1引用的对象是相同的,改变bf2也会改变bf1var bf3 = new Buffer(10); bf1.copy(bf3,2,2,3) ; //这样就不影响原来的对象了, //参数2 拷贝到目标对象的第几位//参数3、4 拷贝原对象的第几位到第几位console.log(bf3)//Buffer 类犯法、对象方法Buffer.isEncoding('utf-8'); 模块和包的概念 模块 nodejs中一个js文件就是一个模块,模块中可以通过require(“”)引入node核心模块或 自定义模块或依赖包 包 包是在模块的基础上深层的抽象,模块的集合,他将某个独立功能封装起来,用于发布、更新、依赖管理版本控制, 通过npm获取需求 node的内置核心模块 http模块 服务端 http模块 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//引入模块var http = require(\"http\");``//====================================================//原生的创建服务var server = new http.Server();server.on(\"request\",function(req,res)&#123; //响应头 res.writeHead(200,&#123;'Content-Type':'text/html'&#125;) //响应内容 res.write('&lt;h1&gt;启成功&lt;/h1&gt;') //结束响应 res.end('&lt;h1&gt;结束&lt;/h1&gt;')&#125;)server.listen(8080)//====================================================//创建服务//req 请求信息 对应事件:http.ServerRequest,//res 响应信息 对应事件:http.ServerResponsehttp.createServer(function(req,res)&#123; //获得请求url console.log(req.url) //post方式体积大 -- 分段 var str = \"\"; //获取post方式请求的数据 req.on(\"data\",function(chunk)&#123; str += chunk; &#125;) //数据全部到达时执行 req.on(\"end\",function()&#123; console.log(str) &#125;) //请求相关事件 //data：当请求体数据到来时，该事件被触发，该事件一共一个参数chunk，表示接受到的数据。 //end：当请求体数据传输完成时，该事件被触发，此后将不会再有数据到来。 //close：用户当前请求结束时，该事件被触发，不同于end，如果用户强制终止了传输，也会触发close //响应头 res.writeHead(200,&#123;'Content-Type':'text/html'&#125;) //告诉浏览器响应内容的格式 //响应内容 res.write('&lt;h1&gt;启ggg成功&lt;/h1&gt;') //结束响应 res.end('&lt;h1&gt;结束&lt;/h1&gt;') //如果没有结束响应,请求的时候回一直转 //监听端口&#125;).listen(8081)//====================================================var server2 = http.createServer();//监听错误server2.on(\"error\",function(err)&#123; console.log(err)&#125;)//请求server2.on(\"request\",function(req,res)&#123; console.log(\"客户的请求server2了\") //响应内容 res.write('&lt;h1&gt;启ggg成功&lt;/h1&gt;'); //结束响应 res.end('&lt;h1&gt;结束&lt;/h1&gt;') //调用该方法告诉服务器所有信息已经发送完成了&#125;)//监听端口成功后触发的事件server2.on(\"listening\",function()&#123; console.log(\"listening...\")&#125;)server2.listen(8082)/* server.listen(port,[hostname],[backlog],[callback]); --port : 监听的端口 --hostnamm : 主机名(IP/域名) --backlog : 连接等待队列的最大长度 --callback : 调用listen监听端口成功之后 会触发一个listening事件,callback将作为该事件的执行函数*/console.log(server2.address()); file模块 文件的每个方法都有对应的同步方法,同步方法没有回调函数(1) open等底层方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859var fs = require(\"fs\")/*fs.open(path,flage,[mode],callback);path: 打开的文件路径flage: 打开文件的方式 读/读写 r/r+[modo]: 设置文件模式 读/写/执行callback: err：打开失败错误信息,如果成功 err = null fd：被打开文件的标识 */fs.open(\"file.txt\",\"r+\",function(err,fd)&#123; //模式是可有可无的 if(err)&#123; //err为错误对象 console.log(\"文件打开失败\") &#125;else&#123; console.log(fd); //当前打开文件的编号 通过这个编号操作file.txt /* ==================fs.read fs.read(fd,buffer,offset,length,posotion,callback); fd:读取文件的到fd buffer:读取数据到这来 offset:读取的信息写入buffer的偏移位置 positong:读取文件的偏移位置 length: 添加多少长度 */ var buf = new Buffer('liaozhongxun'); console.log(buf) fs.read(fd,buf,5,3,2,function(err,len,newbuf)&#123; //err 错误信息 //len 读取字节的长度 //newbuf 新生成的buf对象 , console.log(err) //null console.log(len) //8 console.log(buf.toString()) console.log(newbuf) console.log(buf == newbuf) //true &#125;) /* ===================fs.write fs.write(fd,buffer,offset,length,posotion,callback) fd:操作的文件 buffer:写入文件的数据 offset:buffer 对象中要写入的数据的起始位置 length:要写入的buffer数据的长度 position:写入fd的起始位置 */ var bf2 = new Buffer(\"liaozhong\") fs.write(fd,bf2,0,5,0,function()&#123; console.log(arguments) &#125;) //write bf对象可以改成字符串 //fs.write(fd,str,填写到文件的位置,编码) 添加整个字符串 //fs.close(fd,callback) 关闭文件 &#125;&#125;) (2) 快捷方法 - &gt; 读取文件 123456789101112131415161718192021222324252627282930313233var fs = require(\"fs\");//异步读取fs.readFile('file.txt',function(err,data)&#123; if(err)&#123; console.log(\"读取失败\") &#125;else&#123; console.log(\"readFile异步 后出 得到的内容是\" + data) &#125;&#125;)console.log(\"readFile异步 先出 无阻赛\");//同步读取var SyncFs = fs.readFileSync('file.txt','UTF-8') //同步不需要回调console.log(SyncFs);//删除文件fs.unlink(\"2.txt\",function(err)&#123; if(err)&#123; console.log(\"删除失败\"); &#125;else&#123; console.log(\"删除成功\")) &#125;&#125;)//文件重命名fs.rename(\"2.txt\",\"new.text\",function()&#123;&#125;)//查看文件状态信息fs.stat(\"2.txt\",function(file,fileInfo)&#123; console.log(arguments) fileInfo.modo == 16822 //文件类型为文件夹 fileInfo.modo == 33206 //文件类型为文件&#125;) //文件的信息 (3) 快捷方法 - &gt; 写入文件 12345678var fs = require(\"fs\");var filename = '2.txt';//有这个文件就覆盖,没有就先创建文件在添加fs.writeFile(filename,\"hello\",function()&#123; //参数二可以是 str 也能是buffer&#125;)fs.appendFild() //追加fs.exists(filename,function(err)&#123;err为false就文件不存在&#125;) //判断文件是否存在 (4) 文件watch监听12345678var fs = require(\"fs\");var filename = '2.txt';fs.watch(filename,function(ev,fn)&#123; console.log(ev) //文件发生了什么样的变化 if(fn)&#123; //保证fn的存在，因为有的操作系统不提供fn console.log(fn + \"发生了改变\") &#125;&#125;) (5) 文件夹操作123456789101112var fs = require(\"fs\");//fs.mkdir(path,[modo权限],callback) fs.mkdir(\"./xinjian\",function()&#123;&#125;) //创建文件夹//fs.rmdir(path,function()&#123;&#125;)fs.rmdir(\"./xinjian\",function()&#123;&#125;) // 删除文件夹//fs.readdir(path,function(arr,fileList)&#123;&#125;)fs.readdir(\"./\",function(arr,fileList)&#123; console.log(fileList)&#125;) event 事件 (1)事件方法 EventEmitter.on(event,listener)为指定事件注册一个监听器，接受一个字符串event和一个回调函数listener EventEmitter.emit(event,[arg1],[arg2]....) 发射event事件，传递若干可选参数到事件监听器的参数表 EventEmitter.once(event,listener) 为指定事件注册一个单次监听器，即监听器最多只会触发一次，触发后立刻解除该监听器。 EventEmitter.removeListener(event,listener)移除指定事件的某个监听器，listener必须是该事件已经注册过的监听器。 EventEmitter.removeAllListeners([event]) 移除所有事件的所有监听器，如果指定event，则移除指定事件的所有监听器。 (2) 声明一个事件对象12345678910111213141516171819202122//申明一个事件对象var EventEmitter = require('events').EventEmitter;var event = new EventEmitter();//注册一个事件event.on(\"console_event\",function(arg1,arg2)&#123; //事件名 和该事件所要做的是 console.log(\"这是一个自定义事件\",arg1,arg2)&#125;)//注册的事件有多个监听器 触发是两个方法依次执行event.on(\"console_event\",function()&#123; //事件名 和该事件所要做的是 console.log(\"这是第二个个自定义事件\")&#125;)//触发事件event.emit(\"console_event\",\"参数1\",\"参数2\");event.emit(\"console_event\",\"参数1\",\"参数2\"); //如果是 once方式注册的 这里就不会触发了// 输出// 这是一个自定义事件 参数1 参数2// 这是第二个个自定义事件event.emit(\"error\") //内置事件 直接可以触发 (3) nodejs的事件循环机制 node程序是由事件循环开始到事件循环结束,所有逻辑都是事件的回调函数 util (1) util 提供的继承 util.inherits(Sub,Parent)12345678910111213141516171819202122232425var util = require(\"util\");function Base()&#123; this.name = \"base\"; this.say = function()&#123; console.log( this.name + \"的函数\") &#125;&#125;Base.prototype.giveSub=function()&#123; console.log(\"给你\")&#125;function Sub()&#123;&#125;util.inherits(Sub,Base); //Sub 构造函数继承 Base.prototype的所有方法var Base = new Base();Base.say(); //正常Base.giveSub(); //正常var Sub = new Sub();Sub.say(); //报错Sub.giveSub(); //给你 (2)util.inspect(object,[showHidden],[depth],[colors]) 1234567console.log(Base)console.log(util.inspect(Base))console.log(util.inspect(Base,true,2,true))//showHidden : 是一个可选参数，如果值为true，将会输出更多隐藏信息.//depth : 标识最大的递归的层数，如果对象很复杂，你可以指定层数以控制输出信息的多少。默认为2层，指定为null打印出来全部//color为true，输出格式将会以ANSI颜色编码，通常用于在终端显示更漂亮的效果。 Url 1234567891011121314var url = require(\"url\");//解析客户端到服务的的url 参数二默认为false,改为true的话 会对象形式输出queryurlarr = url.parse(url,false,true) var url = require('url');url.format(&#123; //将对象转为url protocol: 'http:', hostname:'www.baidu.com', port:'80', pathname :'/news', query:&#123;page:1&#125;&#125;); Path1234567891011121314151617181920var path = require(\"path\");//normalize函数将不符合规范的路径经过格式化转换为标准路径path.normalize('/path///normalize/hi/..'); // '/path/normalize/' ,解析路径中的.与..外，还能去掉多余的斜杠。//组合路径path.join('///you', '/are', '//beautiful'); // '/you/are/beautiful'//dirname函数用来返回路径中的目录名path.dirname('/foo/strong/cool/nice') // '/foo/strong/cool'; basename函数可返回路径中的最后一部分，并且可以对其进行条件排除例1：path.basename('路径字符串');var data1 = path.basename('/foo/strong/basename/index.html'); //index.html例2：path.basename('路径字符串', '[ext]')&lt;排除[ext]后缀字符串&gt;;var data2 = path.basename('/foo/strong/basename/index.html','.html'); //index//返回文件扩展名path.extname('index.html'); //.html 没有点则返回空 querystring 序列化对象 1234567891011121314151617181920212223242526272829var querystring = require(\"querystring\");//(1)将一个对象序列化为querystring字符串querystring.stringify(&#123; foo: 'bar', baz: ['qux', 'quux'], corge: '' &#125;)// returns'foo=bar&amp;baz=qux&amp;baz=quux&amp;corge='//指定分隔符querystring.stringify(&#123;foo: 'bar', baz: 'qux'&#125;, ';', ':')// returns'foo:bar;baz:qux'//中午编码querystring.stringify( &#123; w: '中文', foo: 'bar' &#125;, null, null, &#123; encodeURIComponent: gbkEncodeURIComponent &#125;)// returns'w=%D6%D0%CE%C4&amp;foo=bar'//(2)将querystring字符串反序列化为对象//querystring.parse(str[, sep][, eq][, options])querystring.parse('foo=bar&amp;baz=qux&amp;baz=quux&amp;corge')// returns&#123; foo: 'bar', baz: ['qux', 'quux'], corge: '' &#125; NODE WOS","tags":[]},{"title":"ES6","date":"2016-12-18T11:58:28.000Z","path":"2016/12/18/ES6/","text":"let关键字特点 (1) 不允许重复声明同一个变量 (2) 使js有块级作用域( 在{}中定义的变量比如if、for里的变量外面不能访问,每个作用域只能范围其内部的变量 ) (3) 没有与解析的过程(先访问后定义 值不是undefined而是报错) (4) let的代码块(作用域)下,从一开始到let定义一个变量之间的区域,这个变量无法使用,就是暂存死区 const常量 const定义的变量不能修改,但是如果常量是一个对象,那么对象里面的属性是能修改的 扩展运算符12var str = \"liao\"; //代表ES6中所有有遍历接口的数组或类数组 var arr = [...str] // arr = [\"l\",\"i\",\"a\",\"o\"] 解构赋值 解构赋值是ec6通过一定模式,从数组或对象中提取值,然后对变量进行赋值 12345678910111213141516//数组的解构var value = [1, 2, 3, 4, 5];var [el1, el2, el3] = value;console.log(el1 +\"、\"+ el2 +\"、\"+ el3) //1、2、3//按顺序,可以深层嵌套//对象的解构var person = &#123;firstName: \"John\", name:\"Meiqu\" ,lastName: \"Doe\"&#125;;var &#123;firstName, lastName&#125; = person; console.log(firstName + \"、\" + lastName) // John 、Doe//根据key解构//深层嵌套var person = &#123;name: &#123;firstName: \"John\", lastName: \"Doe\"&#125;&#125;;var &#123;name: &#123;firstName, lastName&#125;&#125; = person; 作用:函数只能返回一个值,解构赋值可以将函数返回的数组解构出来使用 String 扩展String 方法1234str.repeat(n) //将字符串平铺n次str.includes(char,起始位置) //查找字符串中有没有对应的字符,返回boolstr.startsWith(char,起始位置) //如果str中含有char,并且在头部,返回true,否则falsestr.endsWith(char,起始位置) //如果str中含有char,并且在尾部,返回true,否则false 其他12旧字符串拼接: str = &quot;liao&quot; + a + &quot;xun&quot;;新字符串拼接: str = `liao$&#123;a&#125;xun` Array 扩展Array 方法12var arr = Array.form(divs); //将类数组转成数组,也可以转字符串var arr = Array.of(\"参数一\",\"参数N\") //将所有参数转换为数组 Array 实例 方法123456789var arr = arr.find(function(value,index)&#123; //遍历数组arr return \"条件\" //返回第一个符合条件的数组元素 value&#125;)var arr = arr.findIndex(function(value,index)&#123; //遍历数组arr return \"条件\" //返回第一个符合条件的数组元素 index&#125;)var arr = arr.fill(\"值\",\"开始位置\",\"介绍位置\") //将arr数组的所有元素变为这个值 for of12345for(var value of obj)&#123;&#125; //只能遍历有遍历接口的对象for(var key of arr.keys())&#123;&#125; //遍历数组的keyfor(var value of arr.values())&#123;&#125; //遍历数组的value (默认)for(var [key,value] of arr.entries())&#123;&#125; //遍历数组的key end value 数组推导(新)(1) 数组推导就是通过现有的数组生成新的数组 1234var arr = [1,2,3,4,5]var arr2 = [for(value of arr) value*2] //arr2 = 2 4 7 8 10 var arr2 = [for(value of arr) 可以加判断 value*2] //arr2 = 2 4 7 8 10 Object 扩展(1) 函数返回12ES5 : return &#123;x:x,y:y&#125;ES6 : return &#123;x,y&#125; (2) 对象中的函数123456789var obj = &#123; name:\"o\", showName:function()&#123; return this.name &#125;, showName()&#123; return this.name &#125;&#125; (3) 可以用表达式作为属性名,用中括号括起来 如: [..]:function(){};(4) Object 方法123456789Object.keys(obj) //得到对象的所有keyObject.is(NAN,NAN) //判断两个参数是否相等,返回bool,两个NAN得到true ,0 与 -0 得到falseObject.assign(obj1,obj2,obj3) //合并对象,obj3 覆盖 obj2 覆盖 obj1Object.getPrototypeOf(obj) //获取对象的PrototypeObject.setPrototypeOf(obj,obj1.Prototype) //设置对象的,让obj的prototype指向obj1的prototypeObject.observe(obj,\"回调\",\"事件类型\"); //监测对象的变化,obj发生某个类型变化时,调用回调,Object.unobserve(obj,\"回调\"); //取消监测对象 Proxy 代理对象123456789var pro = new Proxy(obj,&#123; //obj就是要代理的对象,参数二就是对代理对象的处理 set(obj,attr,value)&#123; //对代理对象的设置就会先触发set方法 obj[attr] = value; &#125;, get(obj,attr)&#123; //对代理对象的访问就会先触发get方法 return 出去的值,就是你访问obj对象的attr属性所得到的值 &#125; &#125;)console.log(pro.a) //得到return出来的值 函数扩展参数默认值1function def(a,b=1)&#123;&#125; //调用时默认参数二为1 rest参数 第二种arguments1234function rest(a,b,c,...ddd)&#123; console.log(...ddd)&#125;rest(1,2,3,4,5,6) //打印出4、5、6 箭头函数1234567891011//匿名函数function()&#123;&#125; &lt;===&gt; () =&gt; &#123;&#125; //只有一个操作就不要最后面的大括号了 //不传参要用小括号站位function(a)&#123;&#125; &lt;===&gt; a =&gt; &#123;&#125; //只有一个操作就可以不要大括号了function(a,b)&#123;&#125; &lt;===&gt; (a,b) =&gt; &#123;&#125; //多个参数也要用小括号括起来//箭头函数内的this 指向定义时所在的对象,而不是使用时所作的对象//不能当做构造函数 不能new//箭头函数里面没有arguments有名函数 Reflect 对象1Reflect.ownKeys(obj) //也能返回一个对象的所有key 新增的数据 解构Set1234567//set与数组类似,但他的值不能重复var set = new Set([1,5,5]); // 1 、5 set.size //set 长度set.add(6) //添加一个set元素set.delete(6) //删除set元素6set.has(6) //判断set中是否有6这个元素 返回一个bool值set.clear() //清空set中多有成员 WeaksetMap12345678910var map = new Map([[]]) //参数解构 [[key,value],[key,value]] 不会出现从复的keymap.size //成员数量map.set(\"key\",\"value\") //新增值map.get(\"key\") //获取map.has(\"key\") //判断key是否存在map.delete(\"key\") //删除keymap.clear() //清空所有map.keys()...map.values()...map.entries() //map提供的遍历接口map.forEach(function(val,key)&#123;&#125;) Weakmap遍历接口 lterator 和 SymbolSymbol : ES6引入的新的原始数据类型,通过Symbol可以生成一个独一无二的ID12var s = Symbol() //不能使用new, typeof s为symbolvar s = Symbol(\"s1\") //可以传入值进行标识,即使传入相同的值也不会返回相等ID 部署遍历接口1234567891011Object.prototype[Symbol.iterabor] = function()&#123; var keys = Object.keys(this) //this代表当前调用变量接口的对象 var self = this; var index = 0; return &#123; next()&#123; return index &lt; keys.length ? &#123; value:1,done:false&#125; : &#123;value:undefined,done:true&#125; //value 当前遍历的值,done 当前遍历是否结束 &#125; &#125;&#125; Generator123456789101112131415161718192021function* helloWorldGenerator() &#123; yield 'hello'; yield 'world'; return 'ending'; //return代表函数结束了 //每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield语句（或return语句）为止。换言之，Generator函数是分段执行的，yield语句是暂停执行的标记，而next方法可以恢复执行。&#125;var hw = helloWorldGenerator(); //确保同一个对象hw.next() // &#123; value: 'hello', done: false &#125;hw.next()// &#123; value: 'world', done: false &#125;// next 传的参数通过上一次yield 的返回结果得到hw.next() //遇到return时 done为true// &#123; value: 'ending', done: true &#125;hw.next()// &#123; value: undefined, done: true &#125; Promise12345678910111213141516171819202122232425262728293031var pro = new Promise(function(resolve,reject)&#123; //经过很多操作之后 //resolve() 代表成功状态,reject() 代表失败 resolve();&#125;)pro.then(function()&#123; console.log(\"成功\") //当上面执行 resolve() 的时候走这里&#125;,function()&#123; console.log(\"失败\") //当上面执行 reject() 的时候走这里&#125;).catch(function(e)&#123; //报错时走这里&#125;)---var pro3 = Promist.all([pro1,pro2]);pro3.then(function()&#123; //pro1 和 pro2 都成功(调用resolve())之后 &#125;,function()&#123; //pro1 和 pro2 只要有一个失败(调用reject())就马上走这里&#125;)---var pro3 = Promist.race([pro1,pro2]);pro3.then() //race函数的参数中 只要有一个的状态(变成调用resolve()) 改变,就走成功//race函数的参数中 只要有一个的状态(变成调用reject()) 改变,就走失败 Class1234567891011121314151617181920212223242526272829303132333435363738//====es6// 1class Cat&#123; constructor(name)&#123; //这个类的构造函数 this.name = name; &#125; getName()&#123; return this.name; &#125; static getColor(color)&#123; //静态方法 直接Cat.getColor()调用 console.log(color) &#125;&#125;// 2 继承class Cat2 extends Cat&#123; constructor(name,color)&#123; super(name) //在 constructor 内,super指代父类的contructor, //在 其他方法内,super指定父类的同名方法 this.color = color; &#125; getfafn()&#123; super.getName() &#125;&#125;//已经继承了 并且有自己的color属性//====es6结束//===========================//====原生// 1function Cat(name)&#123; this.name = name;&#125;Cat.prototype.getName = function()&#123; return this&#125;//====原生结束 Module","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://liaozhongxun.github.io/tags/JavaScript/"}]},{"title":"NPM 插件","date":"2016-12-16T03:22:04.000Z","path":"2016/12/16/NPM-插件/","text":"普通插件nodejs 调试插件1234npm install supervisor -g//node server.js 每次更改server服务内容时 需要重启服务才行//supervisor server.js 每次更改server服务内容时 不要重启直接刷新就行 更新 package.json 的依赖12345npm install -g npm-check-updates //ncu 检查版本//ncu -u 更新需要更新的版本//ncu -a 更新所有版本 表格行列拖拽 1npm install table-dragger --save 删除插件(删除node_node_modules)123npm install -g rimraf cd xxx rimraf node_modules 移动端真机调试1npm install spy-debugger -g MySQL模块(node项目下安装之后，该node项目就能连接MySQL了)1npm install mysql 外网映射工具123451、ngrok2、localtunnel npm模块 lt --port 8088 //端口号是本机要映射到外网的服务端口3、pagekite 花生壳等","tags":[{"name":"插件","slug":"插件","permalink":"https://liaozhongxun.github.io/tags/插件/"}]},{"title":"JavaScript基础","date":"2016-12-14T14:59:50.000Z","path":"2016/12/14/JavaScript基础/","text":"基础语法js六中数据类型[number,boolean,string,null,undefined,object]number 1234console.log(Number.MAX_VALUE) //Number的最大值console.log(Number.MIN_VALUE) //Number的最小值console.log(Number.MAX_VALUE + Number.MAX_VALUE) //无穷大console.log(10/0) //数学上没意义,计算机上无穷大 运算符 ++n //先计算,再返回 n++ //先返回,再计算 == //只比较大小,不比较类型(或者 == 会对值进行隐式转换 , === 的不会) 比较运算符与逻辑非返回的一定是Boolean值 &amp;&amp;、|| 两边原则上是布尔类型的,不是的话会自动转换,返回一个boolean值 (其中涉及到短路运算,如果一方以能觉得最终结果,另外一端就不会再算了) (js中,如果两边不是布尔值会得到具体的值,能算的哪边就返回哪边的值) 分支结构与循环 break : 可以用于循环,switch,跳分支结构与循环结构 continue : 只能用于循环,跳出循环 break后可以跟标志位跳到指定的位置 函数 直接定义的函数同一作用域下函数可以先调用后加载称为预加载 变量赋值方式没有预加载 arguments 属性代表其处于的函数的参数数组 递归 : 函数里面嵌套本身 function fn(){ fn() } === function(){ arquments.calee() } 12345678//最简单的递归案例function jieCeng(n)&#123; if( n==1 )&#123; return 1; &#125; //return n * jieCeng(n - 1); return n * calee(n - 1);&#125; 耦合度 : 一次代码发生改变导致其他代码也发生改变(所以程序要低耦合) DOM操作（通过Js对D操作Dom ）获取(get)(1) 获取原生节点 123document.getElementById(\"\");document.getElementsByTagName(\"\"); //通过元素获取 返回HTMLCollection类数组document.getElementsByName(\"\"); //通过类名获取 返回HTMLCollection类数组 通过[i]和.item(i) 得到某一个 (2) 基于节点获取节点 123456789101112131415161718192021//如果元素后直接跟文本或空格,得到的就是文本节点oDiv.lastChild/oDiv.firstChild.nodeValue//获得所有子节点(主流浏览器会回车这类的节点,ie678没有)oDiv.childNodes//获取兄弟节点oDiv.previousSibling/oDiv.nextSibling//获取父节点oDiv.parentNode//获取||设置属性节点//(1) 只获取设置w3c规定的属性 //jQuery的prop() oDiv.属性 修改input的type属性含有兼容性问题//(2) w3c规定的属性和自定义属性 //jQuery的attr() oDiv.getAttribute(\"\"); oDiv.setAttribute(\"\",\"\"); //(3) oDiv.attributes //获取所有属性 (3) 节点类型(nodeType) node.nodeType == 1 //元素节点 node.nodeType == 2 //属性节点 node.nodeType == 3 //文本节点 node.nodeType == 4 //文档节点 (4) 节点的创建和追加与删除 12345678910元素节点: document.createElement(\"标签名称\")文本节点: document.createTextNode(\"标签名称\")属性节点: node.setAttribute(\"节点名\",\"节点值\")节点追加: \"父节点\".appendChild(\"子节点\") \"父节点\".insertBefore(\"newnode\",\"oldnode\") //nownode 放到 oldnode前面 \"父节点\".replaceChild(\"newnode\",\"oldnode\") //nownode 替换到 oldnode删除节点: \"父节点\".removeChild(\"子节点\") \"节点\".remove() (5) 节点的复制 123node.cloneNode(true/false) // true 复制本身节点和属性 + 内部节点// false 只复制本身节点和属性 (6) DOM的css样式操作 – 操作行内样式 获取css样式 : node.style.css样式名称 设置css样式 : node.style.css样式名称 = “样式值” //有则修改没有则添加- 复合样式要用驼峰式命名(因为变量规则没有 - 字符) – 操作外部样式12345678910if (window.getComputedStyle) &#123; style = window.getComputedStyle(obj, null); // 非IE&#125; else &#123; style = obj.currentStyle; // IE&#125;console.log(\"width=\" + style.width + \"height=\" + style.height) BOM操作(操作浏览器主要属性和方法）node上是无法使用的对象属性123456789101112131415161718(1) window.navigator //浏览器信息 window.navigator.appVersion //浏览器版本信息 window.navigator.userAgent //浏览器用户代理信息(2) window.location //地址栏信息 window.location.reload(); //刷新 window.location.href = window.location.href; //刷新(3) window.history //历史记录信息 window.history.length //历史记录数码 window.history.back() //后退 window.history.go(n) //到达任意想去的历史记录(0 刷新 1 前进1页 2 后退一页)(4) window.screen //屏幕信息 console.log(window.screen.height) //高度 console.log(window.screen.width) //宽度 console.log(window.screen.availHeight) //浏览器可用高度 console.log(window.screen.availWidth) //浏览器可用宽度(可视区宽高)(5) window.document //文档对象 window对象方法alert() || confirm() || open() || close() || print() || setInterval() 等 事件操作DOM1级事件(1) 直接写在行间的事件,相当于原生的属性 (2) 定义方式 oDiv.onclick = function(){} (3) 取消DOM1事件: oDiv.onclick = null; (4) return false 取消浏览器默认行为只对DOM1级事件有效(兼容IE低版本) DOM2级事件(1) 相对于DOM1级的优势 给同一个对象设置多个相同的事件 可以操作事件流 (2) 主流浏览器 监听事件: oDiv.addEventListener(“无on事件名”,function(){},事件流)//匿名函数 监听事件取消: oDiv.removeEventListener(“事件”,”函数名”,事件流) //不能取消匿名函数- 事件流: true 事件捕获 、 false 事件冒泡 事件冒泡 : 从外往内依次执行 事件捕获 : 从内往外依次执行- 阻止事件冒泡 : event.stopPropagation() 阻止默认行为 : event.preventDefault() (3) IE9以下 非主流 监听事件 : oDiv.attachEvent(“有on事件名”,function(){}) //只支持冒泡,所以没有第三个参数 监听事件取消 : oDiv.detachEvent(“有on事件名”,function(){})- 阻止事件冒泡 : window.event.cancelBubble() 阻止默认行为 : window.event.returnValue() (4) 事件对象 var event = event || windwo.event; event.clientX 获取鼠标相对于可视区的坐标 event.pageX 获取鼠标相对于页面的坐标 event.screenX 获取鼠标相对于屏幕的坐标 作用域、闭包作用域1、定义 : 作用域就是变量在当前环境now、内部环境fn、再内部环境fn2/fn3….都起作用的现象连成的一条链 称作作用域链 2、作用特点(1) 内部环境能使用外部环境的变量,反之不行(2) 变量或函数的作用域是声明是决定的,而不是运行时 3、作用于中个个同名变量的优先级内部变量&gt;&gt;内部函数&gt;&gt;形参&gt;&gt;外部变量 闭包(1) 定义 : 可以理解为一个外部函数嵌套一个内部函数(这个内部函数就是闭包),形成闭包的条件是外部函数通过return 将内部函数返回出来 无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。12345678910var getfn0 = waifn(100);var getfn1 = waifn(110);var getfn2 = waifn(120);//getfn0/1/2 都是互相独立的没有不好互相影响//getfn() === neifn0()function waifn()&#123; function neifn()&#123;console.log(\"bib\")&#125; return neifn;&#125; (2) 特点时外部环境能通过闭包访问内部函数的变量 (3) 案例 12345678910var arr = [];for(var i = 0; i &lt; 4; i++)&#123; arr[i] = function()&#123; console.log(i); &#125;&#125;arr[0](); //4arr[1](); //4arr[2](); //4arr[3](); //4 以上的结果都是4for循环生成4个访问 i 的函数,for循环之后i的值已经定格为4了,所以输出都是4for循环的作用其实就是生产i次循环体 或者将i存起来,调用是去除对应的i值所以必须在for循环里面调用才行(匿名函数自执行虽然能解决但是不能再外面灵活调用) 12345678910var arr = [];for(var i = 0; i &lt; 4; i++)&#123; arr[i] = (function(n)&#123; console.log(n) &#125;)(i) //调用&#125;arr[0]();这样arr得到的就是执行的返回值,就能不能调用了 如果一定要在外面使用,可以用闭包 1234567891011121314151617181920212223242526272829var arr = [];for(var i = 0; i &lt; 4; i++)&#123; arr[i] = waifn(i) //调用&#125;function waifn(n)&#123; function neifn()&#123; console.log(n) &#125; return neifn;&#125;arr[0]();arr[1]();arr[2]();arr[3]();//也能使用匿名var arr = [];for(var i = 0; i &lt; 4; i++)&#123; arr[i] = (function(i)&#123; return function()&#123; console.log(i) &#125; &#125;)(i)&#125;arr[0]();arr[1]();arr[2]();arr[3](); JS中的面向对象字面量方式创建对象123456var obj = &#123; name : \"liao\", say : function()&#123; console.log() &#125;&#125;; 构造函数方式创建对象function Tiger(){ } 1、call() 和 apply 让一个函数可以调用另外一个函数的方法12345fn.call(obj,fn参数1、......) //将fn所在的作用域变为objfn.apply(obj,[fn参数1、......]) //将fn所在的作用域变为obj在第二个构造函数内 : Person.call(this); //这个构造函数继承了Person 构造函数部分（子构造函数） 2、构造器var obj = new Tiger();12345678910111213141516171819202122232425262728//new内部的动作// Cat.prototype function Cat() &#123; //cat： 猫 this = &#123;&#125;; //让this 指向一个空对象。 this.__proto__ = Cat.prototype; this.age = 18; this.show = function() &#123; console.log(this.age); &#125; this.name = '1123';//污染全局 // return &#123; // name: 12 // &#125;; return this; &#125; // new： 操作符， a+b - * var cat = new Cat(); //通过构造函数 构造一个对象出来。 // new: 内部的原理， // 第0步： 在内存中开辟一块空间。 // 第一步：创建一个新空对象。 // 第二步： 把this 指向到这个空对象。 // 第三步： 把空对象的 内部原型 指向 构造函数的原型对象。 // 第四步： 当构造函数执行完成后，如果么有return的话，那么把当前空对象返回。 obj.constructor; //获得构造器obj instanceof Tiger //判断obj是不是String的实例对象 返回Boolean值 (3) js的封装、继承、多肽封装的成员 公开成员: 构造函数内通过this赋予的成员 私有成员: 构造函数内通过var申明的成员继承(原型继承) –call方法 构造函数中: Person.call(this); - –构造函数prototype继承对象 Tiger.prototype = cat对象/new Person(); //继承其本身与构造器与原型中所以属性 - –prototype添加属性和方法 Tiger.prototype.xxx = xxx;- 如果有继承对象要先继承对象再继承单一成员,对象只能继承一个call继承 构造函数中: Person.call(this); 函数原型中: Employee.prototype = new Person();//创建这个实例对象时，上层构造函数也会给它设置对象成员 原型链继承 当从一个对象那里读取属性或调用方法时，如果该对象自身不存在这样的属性或方法，就会去自己关联的 prototype 对象那里寻找；如果 prototype 没有，又会去 prototype 自己关联的前辈 prototype 那里寻找，直到找到或追溯过程结束为止。 原型链的最末端，就是 Object 构造函数 prototype 属性指向的那一个原型对象 Function, Boolean, String, Date 和 RegExp 这些的 prototype 都是从这个Object传承下来的，但他们各自又定义了自身的属性和方法， 1234567891011121314//遍历对象for(var i in obj)&#123; console.log(i + \":\" obj[i]) //这里不能用obj.i 不然会找obj的i属性 //查看obj的构造器 console.log(obj.constructor) //obj.hasOwnProperty() 方法 if(obj.hasOwnProperty(i))&#123; console.log(\"hasOwnProperty判断出i是对象自身的成员,不是继承的\") &#125;else&#123; console.log(\"hasOwnProperty判断出i不是对象自身的成员,是继承的\") &#125;&#125; 静态成员: 是构造函数直接.出来的，只能通过构造函数调用 多肽 : 同样的操作实现多种状态12//js 通过arguments 是函数传入不同参数而做出不同的处理 可以算是多肽//js 的this关键字可以体现多肽，其可以通过call、apply等方式任意代表其他对象 new Object() 方式创建对象异常 Exception12345678try&#123; //有可能产生异常的语句&#125;catch(e)&#123; //捕捉异常 e是异常信息对象&#125;finally&#123; //不管有没有异常最后一定执行的语句 console.log()&#125; 其他 — js的编译过程是 先申明、后赋值— js没有块级作用域 if(){} for(){} 里定义的变量外面也能用","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://liaozhongxun.github.io/tags/JavaScript/"}]},{"title":"RegExp","date":"2016-12-12T23:01:39.000Z","path":"2016/12/13/RegExp/","text":"正则字符集==&gt; 定义字符集(没有特殊要求就只匹配符合要求的第一个) [a-z] 匹配一个小写字母 [A-Z] 匹配一个大写字母 [ABC] 匹配 A || B || C 中的一个 [0-9] 匹配一个阿拉伯数字 [0-9a-zA-Z_] 匹配一个数字或字母或下划线 [0-9][a-z] 匹配一个数字和一个小写字母 ==&gt; 特别字符集 * : 其前面那个单元出现0次或以上(还是单次匹配 如:[0-9] 返回 &quot;123-4&quot; 中的123) + : 其前面那个单元出现1次或以上(还是单次匹配 如:[0-9] 返回 &quot;123-4&quot; 中的123) ？: 其前面那个单元出现1次或不出现 | : 或 先匹配左边的 如果没有就匹配右边的 . : 可以代替出来 \\n(换行之外的任意字符) \\ : 转义字符( \\* 这个*就没有前面的匹配功能了) $ : 匹配字符串的结尾位置 ^ ：匹配字符串的开始位置 (中括号内表示 取反) ==&gt; 模式修正符 /str/模式修正符 i : 忽略大小写 g : 多次(全局)匹配(全局匹配就没有体现模式单元了) m : 如果有\\n换行，m也能进行多行匹配 可以连续使用 ==&gt; 组合字符 \\d : 表示[0-9] 数字\\D : 表示[^0-9] 非数字\\m : 表示[a-zA-Z0-9_] 字母数值下划线\\M : 表示 非字母数值下划线\\s : 空格\\S : 非空格\\b : 单词边界\\B : 非单词边界 ==&gt; 限定字符 [ ] : 使里面的匹配成为一个单元(如果没有方括号的话每一个字符都是一个单元) {m} : 前面的单元能匹配m次才可以 {m,} : 至少m次 {m,n} : 至少m次,最多n次 ==&gt; () 模式单元 () : 标记一个字表达式的开始和结束,号称 模式单元 优先级高 括号里的字符是拆分出来的子字符串(匹配的返回值的数组中可以得到) () 单元模式的从发使用 var reg = /[0-9]+-[0-9]+ : [0-9]+-[0-9]+/ === /([0-9]+)-\\1 : \\1-\\1/ 1 代表子表达式在数组中的位置,如果有第二个字表达式就用 \\2 但是\\1表示的数据,的类型和数值大小都要一样 多个括号横向拍,有的又有嵌套括号，先从左向右,从外向内(直接打印成数组比较直观) ==&gt; 正向预查 – 正向匹配 (?=…模式(特殊格式指定信息)..) 我们要查找的内容右边必须出现模式中指定的信息要求,才符合条件。右边的辅助条件是不会出现在结果中的 var reg = /pattern(?=模式)/ –正向不匹配 (?!…模式(特殊格式指定信息)…) 我们要查找的内容右边必须不能出现模式中指定的信息要求,才符合条件。 ==&gt; 反向预查 和正向预查一样,只是模式在左边,右边的内容必须符合左边的要求 反向匹配 : var reg = /(?&lt;=模式)pattern/ 反向不匹配 : var reg = /(?&lt; !模式)pattern/ 反向预查据说只有PHP支持 使用正则的方法 正则方法 var reg = new RegExp(正则,”g”,…) reg.test(str) //匹配 返回true 否则返回false reg.exec(str) //返回匹配的字符串 , 否则返回null reg.compile(正则2) //既可以改变检索模式，也可以添加或删除第二个参数。 字符串方法==&gt; str.strFn(正则) str.match(/liao/) //返回第一个匹配到的字符串、匹配到的第一个字符的索引和str str.replace(&quot;字符串||正则&quot;,&quot;替换内容&quot;) //将str中第一个参数或匹配的正则位置,替换成后面的内容 str.search(/reg/ || str) //返回匹配到的字符串的索引,没有就 -1 str.split(/reg/ || str,number) //将字符串以指定的符号分隔为字符串数组 参数二限定取得的数组长度 正则的用法是以匹配到的内容为分割线","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://liaozhongxun.github.io/tags/JavaScript/"}]},{"title":"Ajax","date":"2016-12-11T13:37:05.000Z","path":"2016/12/11/Ajax/","text":"http请求 = 请求 + 响应var xhr = new XMLHttpRequest() 请求 = 请求行 + 请求头 + 请求主体 请求行 (Get/Post , Url , 协议) 对应Ajax的 xhr.open(Get/Post , Url , 是否异步(默认为true)) 请求头 : 浏览器的一些信息 + Content-Type (get方式的没有Content-Type) xhr.setRequestHeader(&apos;Content-Type&apos;,&apos;&apos;) get方式的没有所以不用设置这个 请求主体 :form Date (Get方式的没有) 对应Ajax的 xhr.send(请求主体) get与post方式的差别主要有两个 (1) get通过url发送内容，post通过send函数发送 (2) get不用设置Content-Type,post 要 响应 = 状态行 + 响应头 + 响应主体 状态行 ：主要有一个状态码 xhr.onreadystatechange =function(){ //响应状态发生变化时触发 if(xhr.readyState = 4){ //如果响应完成后执行以下操作 if(xhr.statrs ==200){ //状态码 xhr.responseText //响应主体 } } } 响应头 ==&gt; xhr.setRequestHeader(‘Content-Type’,’数据格式’) 因为send发送的数据是各种各样的,所以要告诉服务器应该怎么处理浏览器发送的数据 ==&gt; Content- 开头的都是是请体的参数,Content-Type就是请求体的类型(get没有请求体所以不会有这些参数) ==&gt; mate标签的 http-equiv=”” 属性用来模拟响应头 ==&gt; 其他属性和方法 xhr.statusText //状态码对应的状态信息 xhr.getAllResponseHeaders() //获取全部响应头信息 xhr.getResponseHeaders(&quot;key&quot;) //获取指定头信息 简单模仿jQuery封装/* ajax({ type: //传输方式 url: //链接的地址 data: //传送的数据 success: //成功回调函数 lose: //失败回调函数 }) ajax({ type:&quot;post&quot;, url:&quot;post.php&quot;, data:&quot;&amp;user=465&amp;pwd=741&quot;, success:function(a){alert(a)}, lose:function(a){alert(&quot;出错了,状态码为&quot;+a)} }); */ function ajax(json){ var type = json.type || &quot;get&quot;; var url = json.url; var data = json.data || &quot;&quot;; var xhr = null; if (window.XMLHttpRequest){ xhr = new XMLHttpRequest(); }else{ xhr = new ActiveXObject( &apos;Microsoft.XMLHTTP&apos; ); } //有时data有带中文的有时会出现乱码 可用encodeURI();解决 //?username=&quot;+encodeURI(姓名)+&quot; 。。。 if(type==&quot;get&quot;)url+=&quot;?&quot;+data+&quot;&amp;&quot;+Math.random(); xhr.open(type,url,true); if (type == &quot;get&quot;){ xhr.send(); }else{ //post传数据方法 必须规定传输数据的格式 //form中默认有的 xhr.setRequestHeader(&apos;content-type&apos;,&apos;application/x-www-form-urlencoded&apos;); xhr.send(data);//不会有缓存问题 } //当状态值发生改名是执行 onr eadystate change xhr.onreadystatechange = function(){ //ajax的工作转态 if (xhr.readyState == 4){ //http转态码 if (xhr.status&gt;=200 &amp;&amp; xhr.status&lt;300){ json.success &amp;&amp; json.success(xhr.responseText) //typeof xhr.responseText 查看获取的数据类型 //eval(xhr.responseText) 如果是字符串就转成ja语句 }else{ json.lose?json.lose(xhr.status):alert(&quot;发生了&quot;+xhr.status+&quot;错误&quot;) } } } }","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://liaozhongxun.github.io/tags/JavaScript/"}]},{"title":"Markdown","date":"2016-12-10T06:00:57.000Z","path":"2016/12/10/Markdown/","text":"==&gt; 1~6个#分别代表 1~6级标题 ==&gt; 前后 123```javascriptvar a = 10; ==&gt; 一个 &gt; 标注行头, 两个则嵌套 尖括号嵌套 ==&gt; 加粗 1**加粗** 加粗 Cmd Markdown ==&gt; 倾斜1*倾斜* 倾斜 ==&gt; * 创建列表 123&gt; * List1&gt; * List2&gt; * List3 List1 List2 List3 ==&gt; ! [ alt属性值 ] (图片路径) //创建一个图片 ==&gt; [连接内容] ( 连接地址 ) 创建一个连接 百度 ==&gt; &lt; i class=”icon-file “ &gt; &lt; /i &gt; 引用ico小图标 ==&gt; 前后一个 ` ,添加背景 Ctrl+Alt+N ==&gt; - [x] 复选框 前后必须是空行(没有叉叉代表没选中) [ ] 复选框 [x] 复选框 ==&gt; 绘制表格 | —: | :— |:—:| 控制方向 有这种线的上行代表表头 12345| 项目 | 价格 | 数量 || -------- | -----: | :----: || 计算机 | \\$1600 | 5 || 手机 | \\$12 | 12 || 管线 | \\$1 | 234 | 项目 价格 数量 计算机 \\$1600 5 手机 \\$12 12 管线 \\$1 234","tags":[{"name":"标记语言","slug":"标记语言","permalink":"https://liaozhongxun.github.io/tags/标记语言/"}]},{"title":"git使用基础","date":"2016-12-10T03:52:04.000Z","path":"2016/12/10/Git使用基础/","text":"==&gt; git命令中一般 - 跟简称 – 跟全称 （ 如: -h/–help） ==&gt; git init //创建本地git仓库 ==&gt; git config -h //帮助 ==&gt; git config –list //查看git所有配置 git 配置分为三部分 1、本地配置位于本地仓库的隐藏文件夹.git/config 文件 默认以core开头 git config --local --list (只 本地配置) 2、全局配置位于用户的根目录下 .gitconfig //需要进行过全局配置才会有该文件 git config --global --list (只 全局配置) 3、系统配置位于git的安装目录下 git config --system --list (只 系统配置) (优先级依次降低 如果三个配置文件中都有同样的配置优先以本地为准) ==&gt; git config –[local/global/system] obj.键 + 空格 + 值 //修改、添加配置 ==&gt; git config –[local/global/system] –unset obj.键 //删除配置 ==================git分区 ==&gt; 工作区 (.git 所在的工作目录) ==&gt; 暂存区 ==&gt; 仓库 （.git 这个目录就是仓库） ==&gt; git status 查看文件状态 刚新建的文件/修改 --&gt; 未跟踪的文件（红色不会被提交） git add 文件名/夹 --&gt; 成为跟踪文件 (绿色) git rm --cached 文件名 --&gt; 取消跟踪状态 git commit -m &quot;提交说明&quot; || git commit 回车(进入编辑器) --&gt; i(进入编辑模式) --&gt; esc (退出编辑模式) --&gt; :wq(保存并退出) 链接 : git remote add origin http.. || ssh 推送 : git push -u origin master(分支) (第二次就直接push就行了) ==&gt; git pull 拉取远程仓库内容到本地(更新) ==&gt; git branch 分支名 //新建分支 git branch 分支名 &apos;commit id&apos; //基于某一次提交的分支 git branch //查看分支 前面有 * 的就是当前指向的分支(head指向的分支) git branch -a //显示隐藏分支 12345678910111213141516171819202122232425如果你现快速的代上面的分支，你可以直接切换到那个分支：$ git checkout origin/experimental但是，如果你想在那个分支工作的话，你就需要创建一个本地分支：$ git checkout -b experimental origin/experimental现在，如果你看看你的本地分支，你会看到：$ git branch master* experimental你还可以用git remote命令跟踪多个远程分支$ git remote add win32 git://gutup.com/users/joe/myproject-linux-port$ git branch -a* master origin/HEAD origin/master origin/v1.0-stable origin/experimental linux/master linux/new-widgets git branch -d 分支名 //删除分支 -D 强制删除没有合并的分支 git checkout 分支名 //切换到该分支(会检出该分支最后一次提交的代码到工作区) git checkout -b 分支名 // -b表示创建并切换 git branch -v 查看本地与远程分支的同步信息 -vv 更详细的信息 拉取远程分支到本地: git checkout --track(跟踪关系) &quot;主机名(origin)/分支名&quot; 如果远程直接新建的要先 git remote update 一下 合并分支: git merge 分支名 //在某个分支上将指定分支拉取过来 如果有冲突，会自动建立一个临时分支 &lt;&lt;&lt;&lt;Head ... ==== ---- &gt;&gt;&gt;&gt;testing 改好提交就行行了 git clone -b 分支名 仓库地址 //克隆仓库中指定分支内容 git push --set-upstream origin 分支名 //提交到指定分支(当前所在的分支) 重置暂存区: git reset 文件名/HEAD(所有) (仅仅重置暂存区,返回add操作之前) git reset --hard //重置掉当前工作目录回到上一次提交danq git reset --hard HEAD^ 回到上两次提交 以此类推 git reset --hard &quot;commit id&quot; 回到指定提交 git reflog //记录每一次提交操作，包括重置掉的id ==&gt; git clone http.. || ssh 克隆远程仓库 ==&gt; git checkout 检出文件(当一个文件改错了 想从历史中拿一个版本来替换是做的) git checkout 通过commit id 指定哪个版本(没指定的话就用最近一次提交的版本) 文件名 ==&gt; git status //贮藏工作区(保存当前修改又不想提交的文件 之后) git status show 查看贮藏内容 git status pop 取出贮藏内容 ==&gt; 忽略文件 （成功之后查看状态时就不会显示它了） 1、工作区根目录下 创建文件 .gitignore 文件 2、规定忽略规则(在文件里写入文件/文件夹名就好 可以是路径（更多...）) 3、该文件可存在于个个目录 ==&gt; git log 查看日志 1、commit id 重要 ==================远程仓库 ==&gt; github ==&gt; 开源中国 本地仓库与远程仓库名必须相同 ==&gt; 生产本机的ssh 1、git下输入 ssh-keygen 连续回车生成公私钥（公私钥与本台计算机有关） 2、公私钥匙用户家目录下的 .ssh 文件夹中 私钥 : id_rsa 公钥 : id_rsa.pub 3、复制公钥的内容到远程仓库(GitHub 或 开源中国等） 添加成功后本台计算机就能和远程仓库进行交换了","tags":[{"name":"版本控制","slug":"版本控制","permalink":"https://liaozhongxun.github.io/tags/版本控制/"}]},{"title":"hexp+GitHub搭建博客","date":"2016-12-09T14:47:32.000Z","path":"2016/12/09/hexp-GitHub搭建博客/","text":"1、基本介绍 ==&gt; 首先安装node与git ==&gt; 进入hexo.io 按照给的提升全局安装hexo、创建hexo项目、npm install 等 npm install hexo-cli -g hexo init blog cd blog npm install hexo server ==&gt; 进入 _config.yml 文件设置一下博客配置 如 title 等 配置完成之后需要 $ hexo generate 一下重新生成文件 ==&gt; \\scaffolds\\ 下得文件表示不同的网页 文章是基于页面新建的 ==&gt; \\source\\_postsm 下存放的是写的文章 写文章可通过 hexo new &quot;文章名&quot; || 直接新建md文件 hexo new 的文章默认以 `\\scaffolds\\post.md` 文件为模板 hexo new page &quot;页面名&quot; 新建一个页面里面有一个默认的index.md 文件 设置 post_asset_folder: TRUE 之后新建时同时生产相应的资源文件夹(直接访问) ==&gt; public 本地部署所在文件夹 ==&gt; 部署时会将项目中 \\source\\img\\* 的图片部署到使用环境的img文件夹中 2、主题切换 ==&gt; 主题晚上随意下载、存放在 目录\\themes 下就可以使用==&gt; 主题切换: 将_config.yml 下 theme 得值设为需要展示的主题就好了==&gt; 主题中也有 _config.yml 文件配置针对于该主题的一些信息 3、部署到git上==&gt; 首先安装hexo-deployer-git 1$ npm install hexo-deployer-git --save ==&gt; 其次修改配置(_config.yml 的最后) 12345deploy: type: git repo: &lt;repository url&gt; 仓库地址 ssh : http:// branch: [branch] 分支名 如: master message: [message] 消息随便写 ==&gt; 一件部署之后就能直接访问1$ hexo generate --deploy 4、优化1、进入百度站长平台或Google站长平台(https://www.google.com/webmasters/tools) 进行验证 2、两者都可以通过文件验证 ---&gt; 过程是下载他们的的验证文件，放到根目录下(hexo是\\source\\目录) ---&gt; 在上方添加 layout: false 换行 --- ,目的是禁止hexo对该文件进行编译 ---&gt; hexo generate --deploy 重新生成一下 ---&gt; 按照后方的提示就能够通过验证了 3、网站地图 sitemap.xml and baidusitemap.xml ---&gt; npm install hexo-generator-sitemap --save npm install hexo-generator-baidu-sitemap --save ---&gt; 安装完成之后在_config.yml 最后添加以下代码，生成map文件 12345# sitemap sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml ---&gt; 然后在谷歌的`抓取 -&gt; 站点地图` 或百度的 `提交连接 -&gt; 自动提交 -&gt; sitemap` 下按提示添加就好了 ---&gt; 但是百度很坑，提交的时候自动在我前面加上了**http://** 然后提示格式不正确抓取不成功","tags":[{"name":"技术","slug":"技术","permalink":"https://liaozhongxun.github.io/tags/技术/"}]}]